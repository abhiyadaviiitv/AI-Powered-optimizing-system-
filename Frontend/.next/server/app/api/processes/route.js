"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/processes/route";
exports.ids = ["app/api/processes/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-page.runtime.dev.js":
/*!*************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-page.runtime.dev.js" ***!
  \*************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-page.runtime.dev.js");

/***/ }),

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("path");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fprocesses%2Froute&page=%2Fapi%2Fprocesses%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fprocesses%2Froute.ts&appDir=%2Fhome%2Fabhijeet%2FDesktop%2FOS%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fabhijeet%2FDesktop%2FOS&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fprocesses%2Froute&page=%2Fapi%2Fprocesses%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fprocesses%2Froute.ts&appDir=%2Fhome%2Fabhijeet%2FDesktop%2FOS%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fabhijeet%2FDesktop%2FOS&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _home_abhijeet_Desktop_OS_app_api_processes_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./app/api/processes/route.ts */ \"(rsc)/./app/api/processes/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/processes/route\",\n        pathname: \"/api/processes\",\n        filename: \"route\",\n        bundlePath: \"app/api/processes/route\"\n    },\n    resolvedPagePath: \"/home/abhijeet/Desktop/OS/app/api/processes/route.ts\",\n    nextConfigOutput,\n    userland: _home_abhijeet_Desktop_OS_app_api_processes_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks } = routeModule;\nconst originalPathname = \"/api/processes/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZwcm9jZXNzZXMlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRnByb2Nlc3NlcyUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRnByb2Nlc3NlcyUyRnJvdXRlLnRzJmFwcERpcj0lMkZob21lJTJGYWJoaWplZXQlMkZEZXNrdG9wJTJGT1MlMkZhcHAmcGFnZUV4dGVuc2lvbnM9dHN4JnBhZ2VFeHRlbnNpb25zPXRzJnBhZ2VFeHRlbnNpb25zPWpzeCZwYWdlRXh0ZW5zaW9ucz1qcyZyb290RGlyPSUyRmhvbWUlMkZhYmhpamVldCUyRkRlc2t0b3AlMkZPUyZpc0Rldj10cnVlJnRzY29uZmlnUGF0aD10c2NvbmZpZy5qc29uJmJhc2VQYXRoPSZhc3NldFByZWZpeD0mbmV4dENvbmZpZ091dHB1dD0mcHJlZmVycmVkUmVnaW9uPSZtaWRkbGV3YXJlQ29uZmlnPWUzMCUzRCEiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ2M7QUFDSTtBQUNqRjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0hBQW1CO0FBQzNDO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWTtBQUNaLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFpRTtBQUN6RTtBQUNBO0FBQ0EsV0FBVyw0RUFBVztBQUN0QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ3VIOztBQUV2SCIsInNvdXJjZXMiOlsid2VicGFjazovL29zLz8zNzAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEFwcFJvdXRlUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9hcHAtcm91dGUvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgcGF0Y2hGZXRjaCBhcyBfcGF0Y2hGZXRjaCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2xpYi9wYXRjaC1mZXRjaFwiO1xuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi9ob21lL2FiaGlqZWV0L0Rlc2t0b3AvT1MvYXBwL2FwaS9wcm9jZXNzZXMvcm91dGUudHNcIjtcbi8vIFdlIGluamVjdCB0aGUgbmV4dENvbmZpZ091dHB1dCBoZXJlIHNvIHRoYXQgd2UgY2FuIHVzZSB0aGVtIGluIHRoZSByb3V0ZVxuLy8gbW9kdWxlLlxuY29uc3QgbmV4dENvbmZpZ091dHB1dCA9IFwiXCJcbmNvbnN0IHJvdXRlTW9kdWxlID0gbmV3IEFwcFJvdXRlUm91dGVNb2R1bGUoe1xuICAgIGRlZmluaXRpb246IHtcbiAgICAgICAga2luZDogUm91dGVLaW5kLkFQUF9ST1VURSxcbiAgICAgICAgcGFnZTogXCIvYXBpL3Byb2Nlc3Nlcy9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3Byb2Nlc3Nlc1wiLFxuICAgICAgICBmaWxlbmFtZTogXCJyb3V0ZVwiLFxuICAgICAgICBidW5kbGVQYXRoOiBcImFwcC9hcGkvcHJvY2Vzc2VzL3JvdXRlXCJcbiAgICB9LFxuICAgIHJlc29sdmVkUGFnZVBhdGg6IFwiL2hvbWUvYWJoaWplZXQvRGVza3RvcC9PUy9hcHAvYXBpL3Byb2Nlc3Nlcy9yb3V0ZS50c1wiLFxuICAgIG5leHRDb25maWdPdXRwdXQsXG4gICAgdXNlcmxhbmRcbn0pO1xuLy8gUHVsbCBvdXQgdGhlIGV4cG9ydHMgdGhhdCB3ZSBuZWVkIHRvIGV4cG9zZSBmcm9tIHRoZSBtb2R1bGUuIFRoaXMgc2hvdWxkXG4vLyBiZSBlbGltaW5hdGVkIHdoZW4gd2UndmUgbW92ZWQgdGhlIG90aGVyIHJvdXRlcyB0byB0aGUgbmV3IGZvcm1hdC4gVGhlc2Vcbi8vIGFyZSB1c2VkIHRvIGhvb2sgaW50byB0aGUgcm91dGUuXG5jb25zdCB7IHJlcXVlc3RBc3luY1N0b3JhZ2UsIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2UsIHNlcnZlckhvb2tzIH0gPSByb3V0ZU1vZHVsZTtcbmNvbnN0IG9yaWdpbmFsUGF0aG5hbWUgPSBcIi9hcGkvcHJvY2Vzc2VzL3JvdXRlXCI7XG5mdW5jdGlvbiBwYXRjaEZldGNoKCkge1xuICAgIHJldHVybiBfcGF0Y2hGZXRjaCh7XG4gICAgICAgIHNlcnZlckhvb2tzLFxuICAgICAgICBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlXG4gICAgfSk7XG59XG5leHBvcnQgeyByb3V0ZU1vZHVsZSwgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIG9yaWdpbmFsUGF0aG5hbWUsIHBhdGNoRmV0Y2gsICB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHAtcm91dGUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fprocesses%2Froute&page=%2Fapi%2Fprocesses%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fprocesses%2Froute.ts&appDir=%2Fhome%2Fabhijeet%2FDesktop%2FOS%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fabhijeet%2FDesktop%2FOS&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./app/api/processes/route.ts":
/*!************************************!*\
  !*** ./app/api/processes/route.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GET: () => (/* binding */ GET),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   revalidate: () => (/* binding */ revalidate)\n/* harmony export */ });\n/* harmony import */ var next_server__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/server */ \"(rsc)/./node_modules/next/dist/api/server.js\");\n/* harmony import */ var _lib_processData__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../lib/processData */ \"(rsc)/./lib/processData.ts\");\n\n\nconst dynamic = \"force-dynamic\";\nconst revalidate = 0;\nasync function GET(request) {\n    try {\n        const { searchParams } = request.nextUrl;\n        const algorithm = searchParams.get(\"algorithm\") ?? undefined;\n        const payload = await (0,_lib_processData__WEBPACK_IMPORTED_MODULE_1__.getProcessesPayload)(algorithm);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json(payload, {\n            headers: {\n                \"Cache-Control\": \"no-store, must-revalidate\"\n            }\n        });\n    } catch (error) {\n        console.error(\"Failed to load process data\", error);\n        return next_server__WEBPACK_IMPORTED_MODULE_0__.NextResponse.json({\n            error: \"Failed to load process data\"\n        }, {\n            status: 500\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9hcHAvYXBpL3Byb2Nlc3Nlcy9yb3V0ZS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF3RDtBQUNPO0FBRXhELE1BQU1FLFVBQVUsZ0JBQWdCO0FBQ2hDLE1BQU1DLGFBQWEsRUFBRTtBQUVyQixlQUFlQyxJQUFJQyxPQUFvQjtJQUM1QyxJQUFJO1FBQ0YsTUFBTSxFQUFFQyxZQUFZLEVBQUUsR0FBR0QsUUFBUUUsT0FBTztRQUN4QyxNQUFNQyxZQUFZRixhQUFhRyxHQUFHLENBQUMsZ0JBQWdCQztRQUNuRCxNQUFNQyxVQUFVLE1BQU1WLHFFQUFtQkEsQ0FBQ087UUFFMUMsT0FBT1IscURBQVlBLENBQUNZLElBQUksQ0FBQ0QsU0FBUztZQUNoQ0UsU0FBUztnQkFDUCxpQkFBaUI7WUFDbkI7UUFDRjtJQUNGLEVBQUUsT0FBT0MsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsK0JBQStCQTtRQUM3QyxPQUFPZCxxREFBWUEsQ0FBQ1ksSUFBSSxDQUFDO1lBQUVFLE9BQU87UUFBOEIsR0FBRztZQUFFRSxRQUFRO1FBQUk7SUFDbkY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL29zLy4vYXBwL2FwaS9wcm9jZXNzZXMvcm91dGUudHM/YmNlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0UmVxdWVzdCwgTmV4dFJlc3BvbnNlIH0gZnJvbSAnbmV4dC9zZXJ2ZXInO1xuaW1wb3J0IHsgZ2V0UHJvY2Vzc2VzUGF5bG9hZCB9IGZyb20gJy4uLy4uLy4uL2xpYi9wcm9jZXNzRGF0YSc7XG5cbmV4cG9ydCBjb25zdCBkeW5hbWljID0gJ2ZvcmNlLWR5bmFtaWMnO1xuZXhwb3J0IGNvbnN0IHJldmFsaWRhdGUgPSAwO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gR0VUKHJlcXVlc3Q6IE5leHRSZXF1ZXN0KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBzZWFyY2hQYXJhbXMgfSA9IHJlcXVlc3QubmV4dFVybDtcbiAgICBjb25zdCBhbGdvcml0aG0gPSBzZWFyY2hQYXJhbXMuZ2V0KCdhbGdvcml0aG0nKSA/PyB1bmRlZmluZWQ7XG4gICAgY29uc3QgcGF5bG9hZCA9IGF3YWl0IGdldFByb2Nlc3Nlc1BheWxvYWQoYWxnb3JpdGhtKTtcblxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihwYXlsb2FkLCB7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDYWNoZS1Db250cm9sJzogJ25vLXN0b3JlLCBtdXN0LXJldmFsaWRhdGUnXG4gICAgICB9XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgcHJvY2VzcyBkYXRhJywgZXJyb3IpO1xuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbih7IGVycm9yOiAnRmFpbGVkIHRvIGxvYWQgcHJvY2VzcyBkYXRhJyB9LCB7IHN0YXR1czogNTAwIH0pO1xuICB9XG59XG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiZ2V0UHJvY2Vzc2VzUGF5bG9hZCIsImR5bmFtaWMiLCJyZXZhbGlkYXRlIiwiR0VUIiwicmVxdWVzdCIsInNlYXJjaFBhcmFtcyIsIm5leHRVcmwiLCJhbGdvcml0aG0iLCJnZXQiLCJ1bmRlZmluZWQiLCJwYXlsb2FkIiwianNvbiIsImhlYWRlcnMiLCJlcnJvciIsImNvbnNvbGUiLCJzdGF0dXMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./app/api/processes/route.ts\n");

/***/ }),

/***/ "(rsc)/./lib/processData.ts":
/*!****************************!*\
  !*** ./lib/processData.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getProcessesPayload: () => (/* binding */ getProcessesPayload)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var csv_parse_sync__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! csv-parse/sync */ \"(rsc)/./node_modules/csv-parse/lib/sync.js\");\n\n\n\nconst ALGORITHM_DESCRIPTIONS = {\n    \"First Come First Serve (FCFS)\": \"Processes are executed in the order they arrive. Simple but can lead to longer waiting times for later jobs.\",\n    \"Shortest Job First (SJF)\": \"Chooses the process with the smallest execution time next. Minimizes average waiting time but requires knowing burst lengths.\",\n    \"Shortest Remaining Time First (SRTF)\": \"Preemptive version of SJF that always runs the job with the least remaining time.\",\n    \"Priority Scheduling\": \"Executes processes based on priority levels. Lower priority numbers indicate higher importance by default.\",\n    \"Multilevel Feedback Queue (MLFQ)\": \"Uses multiple queues with variable priorities and time quantums, adapting to process behavior over time.\"\n};\nconst EXCLUDED_ALGORITHMS = new Set([\n    \"Round Robin (RR)\"\n]);\nconst DEFAULT_DATA_FILE = path__WEBPACK_IMPORTED_MODULE_1___default().join(process.cwd(), \"scheduler_results (1).csv\");\nconst COLOR_PALETTE = [\n    \"#ff61d2\",\n    \"#845ec2\",\n    \"#f9f871\",\n    \"#ff9671\",\n    \"#00c9a7\",\n    \"#0081cf\",\n    \"#f24c00\",\n    \"#ff6f91\",\n    \"#2c73d2\",\n    \"#00c9c8\"\n];\nfunction toNumber(value) {\n    if (!value || value.trim() === \"\") {\n        return null;\n    }\n    const num = Number(value);\n    return Number.isFinite(num) ? num : null;\n}\nasync function readCsvRecords() {\n    const filePath = process.env.SCHEDULER_DATA_FILE ?? DEFAULT_DATA_FILE;\n    const content = await fs__WEBPACK_IMPORTED_MODULE_0__.promises.readFile(filePath, \"utf8\");\n    const records = (0,csv_parse_sync__WEBPACK_IMPORTED_MODULE_2__.parse)(content, {\n        columns: true,\n        skip_empty_lines: true,\n        trim: true\n    });\n    const latestByPid = new Map();\n    for (const record of records){\n        const pid = toNumber(record.pid);\n        if (pid === null || pid === 0 || pid === 4) {\n            continue;\n        }\n        const burstTime = toNumber(record.burst_time) ?? toNumber(record.predicted_burst_time);\n        const arrivalTime = toNumber(record.arrival_time);\n        const systemTimestamp = toNumber(record.system_timestamp) ?? 0;\n        const parsed = {\n            snapshotId: toNumber(record.snapshot_id) ?? 0,\n            systemTimestamp,\n            timestamp: record.timestamp,\n            pid,\n            name: record.name || \"Unknown\",\n            status: record.status || \"unknown\",\n            ppid: toNumber(record.ppid),\n            cpuPercent: toNumber(record.cpu_percent) ?? 0,\n            memoryPercent: toNumber(record.memory_percent) ?? 0,\n            memoryMb: toNumber(record.memory_mb) ?? 0,\n            numThreads: toNumber(record.num_threads),\n            nice: toNumber(record.nice),\n            processAge: toNumber(record.process_age),\n            processType: toNumber(record.process_type),\n            ioIntensity: toNumber(record.io_intensity),\n            userTime: toNumber(record.user_time),\n            systemTime: toNumber(record.system_time),\n            burstTime,\n            predictedBurstTime: toNumber(record.predicted_burst_time),\n            arrivalTime,\n            predictedTimeQuantum: toNumber(record.predicted_time_quantum),\n            predictedPriority: toNumber(record.predicted_priority),\n            recommendedAlgorithm: record.recommended_algorithm || \"First Come First Serve (FCFS)\"\n        };\n        if (EXCLUDED_ALGORITHMS.has(parsed.recommendedAlgorithm)) {\n            continue;\n        }\n        const existing = latestByPid.get(pid);\n        if (!existing || parsed.systemTimestamp >= existing.systemTimestamp) {\n            latestByPid.set(pid, parsed);\n        }\n    }\n    return [\n        ...latestByPid.values()\n    ].sort((a, b)=>a.pid - b.pid);\n}\nfunction normalizeProcesses(processes) {\n    const arrivalValues = processes.map((p)=>p.arrivalTime).filter((value)=>value !== null);\n    const minArrival = arrivalValues.length ? Math.min(...arrivalValues) : 0;\n    return processes.map((process1, index)=>{\n        const burst = process1.burstTime ?? process1.predictedBurstTime ?? 0;\n        const arrival = process1.arrivalTime ?? minArrival;\n        const normalizedArrival = arrival - minArrival;\n        return {\n            ...process1,\n            remainingTime: burst,\n            normalizedArrival,\n            tag: `P${index + 1}`,\n            color: COLOR_PALETTE[index % COLOR_PALETTE.length]\n        };\n    });\n}\nfunction addIdleSegment(segments, currentTime, nextTime) {\n    if (nextTime <= currentTime) {\n        return;\n    }\n    segments.push({\n        pid: null,\n        tag: \"IDLE\",\n        label: \"Idle\",\n        start: currentTime,\n        end: nextTime,\n        duration: nextTime - currentTime,\n        color: \"rgba(255,255,255,0.08)\"\n    });\n}\nfunction simulateFCFS(processes) {\n    const sorted = [\n        ...processes\n    ].sort((a, b)=>a.normalizedArrival - b.normalizedArrival);\n    const segments = [];\n    const stats = new Map();\n    let time = 0;\n    const totalBurst = sorted.reduce((acc, proc)=>acc + (proc.burstTime ?? proc.predictedBurstTime ?? 0), 0);\n    for (const process1 of sorted){\n        const arrival = process1.normalizedArrival;\n        if (time < arrival) {\n            addIdleSegment(segments, time, arrival);\n            time = arrival;\n        }\n        const burst = process1.burstTime ?? process1.predictedBurstTime ?? 0;\n        const start = time;\n        const end = start + burst;\n        segments.push({\n            pid: process1.pid,\n            tag: process1.tag,\n            label: `${process1.tag}`,\n            start,\n            end,\n            duration: burst,\n            color: process1.color\n        });\n        time = end;\n        stats.set(process1.tag, {\n            arrival,\n            burst,\n            completion: end\n        });\n    }\n    const makespan = segments.length ? segments[segments.length - 1].end : 0;\n    const idleTime = segments.filter((segment)=>segment.pid === null).reduce((acc, seg)=>acc + seg.duration, 0);\n    return {\n        segments,\n        stats,\n        idleTime,\n        makespan,\n        totalBurst\n    };\n}\nfunction simulatePriority(processes) {\n    const segments = [];\n    const stats = new Map();\n    const remaining = new Map(processes.map((p)=>[\n            p.tag,\n            p.burstTime ?? p.predictedBurstTime ?? 0\n        ]));\n    let time = 0;\n    const sortedByArrival = [\n        ...processes\n    ].sort((a, b)=>a.normalizedArrival - b.normalizedArrival);\n    const totalBurst = sortedByArrival.reduce((acc, proc)=>acc + (proc.burstTime ?? proc.predictedBurstTime ?? 0), 0);\n    const ready = [];\n    let idx = 0;\n    while(stats.size < processes.length){\n        while(idx < sortedByArrival.length && sortedByArrival[idx].normalizedArrival <= time){\n            ready.push(sortedByArrival[idx]);\n            idx += 1;\n        }\n        if (!ready.length) {\n            const nextArrival = sortedByArrival[idx]?.normalizedArrival;\n            if (nextArrival === undefined) {\n                break;\n            }\n            addIdleSegment(segments, time, nextArrival);\n            time = nextArrival;\n            continue;\n        }\n        ready.sort((a, b)=>{\n            const priorityA = a.predictedPriority ?? Number.MAX_SAFE_INTEGER;\n            const priorityB = b.predictedPriority ?? Number.MAX_SAFE_INTEGER;\n            if (priorityA === priorityB) {\n                return a.normalizedArrival - b.normalizedArrival;\n            }\n            return priorityA - priorityB;\n        });\n        const current = ready.shift();\n        const burst = remaining.get(current.tag) ?? 0;\n        const start = Math.max(time, current.normalizedArrival);\n        const end = start + burst;\n        if (start > time) {\n            addIdleSegment(segments, time, start);\n            time = start;\n        }\n        segments.push({\n            pid: current.pid,\n            tag: current.tag,\n            label: current.tag,\n            start,\n            end,\n            duration: burst,\n            color: current.color\n        });\n        time = end;\n        stats.set(current.tag, {\n            arrival: current.normalizedArrival,\n            burst,\n            completion: end\n        });\n    }\n    const makespan = segments.length ? segments[segments.length - 1].end : 0;\n    const idleTime = segments.filter((segment)=>segment.pid === null).reduce((acc, seg)=>acc + seg.duration, 0);\n    return {\n        segments,\n        stats,\n        idleTime,\n        makespan,\n        totalBurst\n    };\n}\nfunction simulateMLFQ(processes) {\n    const quantums = [\n        4,\n        8,\n        16\n    ];\n    const queues = [\n        [],\n        [],\n        []\n    ];\n    const stats = new Map();\n    const remaining = new Map(processes.map((p)=>[\n            p.tag,\n            p.burstTime ?? p.predictedBurstTime ?? 0\n        ]));\n    const segments = [];\n    const sorted = [\n        ...processes\n    ].sort((a, b)=>a.normalizedArrival - b.normalizedArrival);\n    const totalBurst = sorted.reduce((acc, proc)=>acc + (proc.burstTime ?? proc.predictedBurstTime ?? 0), 0);\n    let time = 0;\n    let idx = 0;\n    const enqueueNewArrivals = ()=>{\n        while(idx < sorted.length && sorted[idx].normalizedArrival <= time){\n            queues[0].push(sorted[idx]);\n            idx += 1;\n        }\n    };\n    const hasReady = ()=>queues.some((q)=>q.length > 0);\n    while(stats.size < processes.length){\n        enqueueNewArrivals();\n        if (!hasReady()) {\n            const nextArrival = sorted[idx]?.normalizedArrival;\n            if (nextArrival === undefined) {\n                break;\n            }\n            addIdleSegment(segments, time, nextArrival);\n            time = nextArrival;\n            enqueueNewArrivals();\n            continue;\n        }\n        let level = queues.findIndex((q)=>q.length > 0);\n        if (level === -1) {\n            level = queues.length - 1;\n        }\n        const current = queues[level].shift();\n        const remainingTime = remaining.get(current.tag) ?? 0;\n        const quantum = quantums[level] ?? quantums[quantums.length - 1];\n        const predictedQuantum = current.predictedTimeQuantum ?? quantum;\n        const actualRun = Math.min(quantum, remainingTime);\n        const start = Math.max(time, current.normalizedArrival);\n        if (start > time) {\n            addIdleSegment(segments, time, start);\n            time = start;\n        }\n        const end = time + actualRun;\n        segments.push({\n            pid: current.pid,\n            tag: current.tag,\n            label: `${current.tag} (Q${level + 1})`,\n            start: time,\n            end,\n            duration: actualRun,\n            color: current.color,\n            queueLevel: level + 1,\n            timeQuantum: predictedQuantum\n        });\n        time = end;\n        enqueueNewArrivals();\n        const updatedRemaining = remainingTime - actualRun;\n        remaining.set(current.tag, updatedRemaining);\n        if (updatedRemaining > 0.0001) {\n            const nextLevel = Math.min(level + 1, queues.length - 1);\n            queues[nextLevel].push(current);\n        } else {\n            const burst = current.burstTime ?? current.predictedBurstTime ?? 0;\n            stats.set(current.tag, {\n                arrival: current.normalizedArrival,\n                burst,\n                completion: time\n            });\n        }\n    }\n    const makespan = segments.length ? segments[segments.length - 1].end : 0;\n    const idleTime = segments.filter((segment)=>segment.pid === null).reduce((acc, seg)=>acc + seg.duration, 0);\n    return {\n        segments,\n        stats,\n        idleTime,\n        makespan,\n        totalBurst\n    };\n}\n/**\n * Computes scheduling metrics for all processes\n * \n * METRICS CALCULATION EXPLANATION:\n * \n * 1. Average Waiting Time:\n *    - For each process: Waiting Time = Completion Time - Arrival Time - Burst Time\n *    - Average = Sum of all waiting times / Number of processes\n *    - This measures how long processes wait in the ready queue before execution\n * \n * 2. Average Turnaround Time:\n *    - For each process: Turnaround Time = Completion Time - Arrival Time\n *    - Average = Sum of all turnaround times / Number of processes\n *    - This measures total time from arrival to completion (waiting + execution)\n * \n * 3. Average Burst Time:\n *    - Average = Sum of all burst times / Number of processes\n *    - This is the average execution time needed by processes\n * \n * 4. Throughput:\n *    - Throughput = Number of processes completed / Makespan\n *    - Measures how many processes complete per unit time\n * \n * 5. CPU Utilization:\n *    - Busy Time = Makespan - Idle Time\n *    - CPU Utilization = (Busy Time / Makespan) * 100%\n *    - Measures percentage of time CPU is busy executing processes\n * \n * 6. Makespan:\n *    - Makespan = End time of the last segment (total time to complete all processes)\n * \n * 7. Idle Time:\n *    - Sum of all idle segments (time when CPU has no processes to execute)\n */ function computeMetrics(stats, segments, totalBurst, idleTime) {\n    const values = [\n        ...stats.values()\n    ];\n    if (!values.length) {\n        return {\n            averageBurstTime: 0,\n            averageTurnaroundTime: 0,\n            averageWaitingTime: 0,\n            throughput: 0,\n            cpuUtilization: 0,\n            makespan: 0,\n            totalBurst: 0,\n            idleTime: 0\n        };\n    }\n    // Makespan = total time from start to finish of all processes\n    const makespan = segments.length ? segments[segments.length - 1].end : 0;\n    // Turnaround Time = Completion Time - Arrival Time (total time in system)\n    const totalTurnaround = values.reduce((acc, { arrival, completion })=>acc + (completion - arrival), 0);\n    // Waiting Time = Completion Time - Arrival Time - Burst Time (time spent waiting)\n    const totalWaiting = values.reduce((acc, { arrival, completion, burst })=>acc + (completion - arrival - burst), 0);\n    // Average Burst Time = Sum of burst times / Number of processes\n    const avgBurst = values.reduce((acc, { burst })=>acc + burst, 0) / values.length;\n    // Throughput = Number of processes / Total time (processes per unit time)\n    const throughput = makespan > 0 ? values.length / makespan : 0;\n    // Busy Time = Total time - Idle time (time CPU was executing processes)\n    const busyTime = Math.max(makespan - idleTime, 0);\n    // CPU Utilization = (Busy Time / Total Time) * 100%\n    const cpuUtilization = makespan > 0 ? busyTime / makespan * 100 : 0;\n    return {\n        averageBurstTime: avgBurst,\n        averageTurnaroundTime: totalTurnaround / values.length,\n        averageWaitingTime: totalWaiting / values.length,\n        throughput,\n        cpuUtilization,\n        makespan,\n        totalBurst,\n        idleTime\n    };\n}\nfunction buildTable(stats, processes, colorByTag) {\n    const tagToProcess = new Map(processes.map((proc)=>[\n            proc.tag,\n            proc\n        ]));\n    return [\n        ...stats.entries()\n    ].map(([tag, { arrival, burst, completion }])=>{\n        const process1 = tagToProcess.get(tag);\n        if (!process1) {\n            throw new Error(`Missing process for tag ${tag}`);\n        }\n        return {\n            pid: process1.pid,\n            tag,\n            name: process1.name,\n            arrivalTime: Number(arrival.toFixed(2)),\n            burstTime: Number(burst.toFixed(2)),\n            waitingTime: Number((completion - arrival - burst).toFixed(2)),\n            turnaroundTime: Number((completion - arrival).toFixed(2)),\n            completionTime: Number(completion.toFixed(2)),\n            color: colorByTag.get(tag) ?? \"#999\",\n            timeQuantum: process1.predictedTimeQuantum ?? null\n        };\n    }).sort((a, b)=>a.arrivalTime - b.arrivalTime);\n}\nfunction formatSegments(segments) {\n    return segments.map((segment)=>({\n            ...segment,\n            start: Number(segment.start.toFixed(2)),\n            end: Number(segment.end.toFixed(2)),\n            duration: Number(segment.duration.toFixed(2))\n        }));\n}\nfunction simulateSJF(processes) {\n    const sorted = [\n        ...processes\n    ].sort((a, b)=>{\n        const burstA = a.burstTime ?? a.predictedBurstTime ?? 0;\n        const burstB = b.burstTime ?? b.predictedBurstTime ?? 0;\n        if (Math.abs(burstA - burstB) < 0.001) {\n            return a.normalizedArrival - b.normalizedArrival;\n        }\n        return burstA - burstB;\n    });\n    const segments = [];\n    const stats = new Map();\n    let time = 0;\n    const totalBurst = sorted.reduce((acc, proc)=>acc + (proc.burstTime ?? proc.predictedBurstTime ?? 0), 0);\n    for (const process1 of sorted){\n        const arrival = process1.normalizedArrival;\n        if (time < arrival) {\n            addIdleSegment(segments, time, arrival);\n            time = arrival;\n        }\n        const burst = process1.burstTime ?? process1.predictedBurstTime ?? 0;\n        const start = time;\n        const end = start + burst;\n        segments.push({\n            pid: process1.pid,\n            tag: process1.tag,\n            label: `${process1.tag}`,\n            start,\n            end,\n            duration: burst,\n            color: process1.color\n        });\n        time = end;\n        stats.set(process1.tag, {\n            arrival,\n            burst,\n            completion: end\n        });\n    }\n    const makespan = segments.length ? segments[segments.length - 1].end : 0;\n    const idleTime = segments.filter((segment)=>segment.pid === null).reduce((acc, seg)=>acc + seg.duration, 0);\n    return {\n        segments,\n        stats,\n        idleTime,\n        makespan,\n        totalBurst\n    };\n}\nfunction simulateSRTF(processes) {\n    const segments = [];\n    const stats = new Map();\n    const remaining = new Map(processes.map((p)=>[\n            p.tag,\n            p.burstTime ?? p.predictedBurstTime ?? 0\n        ]));\n    let time = 0;\n    const sortedByArrival = [\n        ...processes\n    ].sort((a, b)=>a.normalizedArrival - b.normalizedArrival);\n    const totalBurst = sortedByArrival.reduce((acc, proc)=>acc + (proc.burstTime ?? proc.predictedBurstTime ?? 0), 0);\n    const ready = [];\n    let idx = 0;\n    while(stats.size < processes.length){\n        // Add newly arrived processes\n        while(idx < sortedByArrival.length && sortedByArrival[idx].normalizedArrival <= time){\n            ready.push(sortedByArrival[idx]);\n            idx += 1;\n        }\n        if (!ready.length) {\n            const nextArrival = sortedByArrival[idx]?.normalizedArrival;\n            if (nextArrival === undefined) {\n                break;\n            }\n            addIdleSegment(segments, time, nextArrival);\n            time = nextArrival;\n            continue;\n        }\n        // Sort by remaining time (SRTF)\n        ready.sort((a, b)=>{\n            const remainingA = remaining.get(a.tag) ?? 0;\n            const remainingB = remaining.get(b.tag) ?? 0;\n            if (Math.abs(remainingA - remainingB) < 0.001) {\n                return a.normalizedArrival - b.normalizedArrival;\n            }\n            return remainingA - remainingB;\n        });\n        const current = ready[0];\n        const remainingTime = remaining.get(current.tag) ?? 0;\n        // Find next event: either next arrival or completion\n        const nextArrival = sortedByArrival[idx]?.normalizedArrival;\n        const timeUntilNext = nextArrival !== undefined ? nextArrival - time : Infinity;\n        const runTime = Math.min(remainingTime, timeUntilNext);\n        const start = time;\n        const end = start + runTime;\n        // Check if we should merge with previous segment\n        const lastSegment = segments[segments.length - 1];\n        if (lastSegment && lastSegment.pid === current.pid && Math.abs(lastSegment.end - start) < 0.0001) {\n            lastSegment.end = end;\n            lastSegment.duration += runTime;\n        } else {\n            segments.push({\n                pid: current.pid,\n                tag: current.tag,\n                label: current.tag,\n                start,\n                end,\n                duration: runTime,\n                color: current.color\n            });\n        }\n        time = end;\n        const updatedRemaining = remainingTime - runTime;\n        remaining.set(current.tag, updatedRemaining);\n        if (updatedRemaining < 0.0001) {\n            // Process completed\n            const burst = current.burstTime ?? current.predictedBurstTime ?? 0;\n            stats.set(current.tag, {\n                arrival: current.normalizedArrival,\n                burst,\n                completion: end\n            });\n            ready.shift();\n        }\n    // If not completed, it stays in ready queue and will be resorted on next iteration\n    }\n    const makespan = segments.length ? segments[segments.length - 1].end : 0;\n    const idleTime = segments.filter((segment)=>segment.pid === null).reduce((acc, seg)=>acc + seg.duration, 0);\n    return {\n        segments,\n        stats,\n        idleTime,\n        makespan,\n        totalBurst\n    };\n}\nfunction simulate(algorithm, processes) {\n    switch(algorithm){\n        case \"First Come First Serve (FCFS)\":\n            return simulateFCFS(processes);\n        case \"Shortest Job First (SJF)\":\n            return simulateSJF(processes);\n        case \"Shortest Remaining Time First (SRTF)\":\n            return simulateSRTF(processes);\n        case \"Priority Scheduling\":\n            return simulatePriority(processes);\n        case \"Multilevel Feedback Queue (MLFQ)\":\n            return simulateMLFQ(processes);\n        default:\n            return simulateFCFS(processes);\n    }\n}\nasync function getProcessesPayload(preferredAlgorithm) {\n    const records = await readCsvRecords();\n    const runningProcesses = records.filter((record)=>record.status.toLowerCase() === \"running\").sort((a, b)=>b.cpuPercent - a.cpuPercent);\n    const dataAlgorithms = new Set(records.map((record)=>record.recommendedAlgorithm));\n    const canonicalAlgorithms = Object.keys(ALGORITHM_DESCRIPTIONS);\n    const mergedAlgorithms = new Set([\n        ...canonicalAlgorithms,\n        ...dataAlgorithms\n    ]);\n    const algorithms = [\n        ...[\n            ...mergedAlgorithms\n        ].filter((name)=>name !== \"Shortest Remaining Time First (SRTF)\") // Exclude SRTF from selector\n        .sort((a, b)=>a.localeCompare(b)).map((name)=>({\n                name,\n                description: ALGORITHM_DESCRIPTIONS[name] ?? \"No description available.\",\n                available: dataAlgorithms.has(name)\n            })),\n        // Add \"Compare All\" option\n        {\n            name: \"Compare All\",\n            description: \"View all algorithms side-by-side and see which performs best overall based on average waiting time.\",\n            available: true\n        }\n    ];\n    // Get first available algorithm (excluding \"Compare All\")\n    const firstAvailable = [\n        ...dataAlgorithms\n    ][0] ?? algorithms.find((alg)=>alg.name !== \"Compare All\")?.name ?? \"First Come First Serve (FCFS)\";\n    // Handle \"Compare All\" - don't treat it as a real algorithm for scheduling\n    const selectedAlgorithm = preferredAlgorithm === \"Compare All\" ? \"Compare All\" : preferredAlgorithm && mergedAlgorithms.has(preferredAlgorithm) ? preferredAlgorithm : firstAvailable;\n    // Get all processes that have burst time and arrival time for scheduling\n    const schedulableProcesses = records.filter((record)=>(record.burstTime ?? record.predictedBurstTime ?? 0) > 0 && record.arrivalTime !== null).sort((a, b)=>(a.arrivalTime ?? 0) - (b.arrivalTime ?? 0));\n    const limited = schedulableProcesses.slice(0, 10);\n    const internalProcesses = normalizeProcesses(limited);\n    // Compute schedules for all algorithms (excluding SRTF since it's not in the dataset)\n    const allSchedules = {};\n    const algorithmMetrics = {};\n    // Filter out SRTF from algorithms to compute (only compute algorithms that are in the dataset or available)\n    const algorithmsToCompute = canonicalAlgorithms.filter((algName)=>algName !== \"Shortest Remaining Time First (SRTF)\");\n    for (const algName of algorithmsToCompute){\n        if (internalProcesses.length) {\n            const simulation = simulate(algName, internalProcesses);\n            const metrics = computeMetrics(simulation.stats, simulation.segments, simulation.totalBurst, simulation.idleTime);\n            const colorMap = new Map(internalProcesses.map((proc)=>[\n                    proc.tag,\n                    proc.color\n                ]));\n            const table = buildTable(simulation.stats, internalProcesses, colorMap);\n            allSchedules[algName] = {\n                segments: formatSegments(simulation.segments),\n                table,\n                metrics\n            };\n            algorithmMetrics[algName] = {\n                avgWaiting: metrics.averageWaitingTime,\n                avgTurnaround: metrics.averageTurnaroundTime\n            };\n        } else {\n            allSchedules[algName] = null;\n        }\n    }\n    // Determine best algorithm for each process based on waiting time\n    const processBestAlgorithm = new Map();\n    for (const process1 of limited){\n        let bestAlg = null;\n        let bestWaiting = Infinity;\n        for (const [algName, schedule] of Object.entries(allSchedules)){\n            if (!schedule) continue;\n            const processRow = schedule.table.find((row)=>row.pid === process1.pid);\n            if (processRow && processRow.waitingTime < bestWaiting) {\n                bestWaiting = processRow.waitingTime;\n                bestAlg = algName;\n            }\n        }\n        if (bestAlg) {\n            processBestAlgorithm.set(process1.pid, bestAlg);\n        }\n    }\n    // Get schedule for selected algorithm (skip if \"Compare All\")\n    const schedule = selectedAlgorithm === \"Compare All\" ? null : allSchedules[selectedAlgorithm] ?? null;\n    const processOverview = runningProcesses.map((process1)=>{\n        const record = records.find((r)=>r.pid === process1.pid);\n        return {\n            pid: process1.pid,\n            tag: `PID ${process1.pid}`,\n            name: process1.name,\n            algorithm: process1.recommendedAlgorithm,\n            cpuPercent: Number(process1.cpuPercent.toFixed(2)),\n            memoryMb: Number(process1.memoryMb.toFixed(2)),\n            status: process1.status,\n            predictedBurstTime: record?.predictedBurstTime ?? null,\n            predictedTimeQuantum: record?.predictedTimeQuantum ?? null,\n            bestAlgorithm: processBestAlgorithm.get(process1.pid)\n        };\n    });\n    let latestTimestamp = null;\n    for (const record of records){\n        if (!record.timestamp) continue;\n        const millis = Date.parse(record.timestamp);\n        if (!Number.isFinite(millis)) {\n            continue;\n        }\n        if (!latestTimestamp || millis > Date.parse(latestTimestamp)) {\n            latestTimestamp = record.timestamp;\n        }\n    }\n    return {\n        algorithms,\n        selectedAlgorithm,\n        algorithmDescription: selectedAlgorithm === \"Compare All\" ? \"View all algorithms side-by-side and see which performs best overall based on average waiting time.\" : ALGORITHM_DESCRIPTIONS[selectedAlgorithm] ?? \"Scheduling visualization\",\n        processes: processOverview,\n        schedule,\n        allSchedules,\n        lastUpdated: latestTimestamp\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFJLENBQUN6QixPQUFPQyxRQUFRLENBQUM2TSxTQUFTO1lBQzVCO1FBQ0Y7UUFDQSxJQUFJLENBQUNELG1CQUFtQkMsU0FBU0MsS0FBSzVOLEtBQUssQ0FBQzBOLGtCQUFrQjtZQUM1REEsa0JBQWtCaE0sT0FBT1ksU0FBUztRQUNwQztJQUNGO0lBRUEsT0FBTztRQUNMcUo7UUFDQU87UUFDQTJCLHNCQUFzQjNCLHNCQUFzQixnQkFDeEMsd0dBQ0NqTSxzQkFBc0IsQ0FBQ2lNLGtCQUFrQixJQUFJO1FBQ2xEckgsV0FBVzBJO1FBQ1hIO1FBQ0FiO1FBQ0F1QixhQUFhSjtJQUNmO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9vcy8uL2xpYi9wcm9jZXNzRGF0YS50cz83ZWE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByb21pc2VzIGFzIGZzIH0gZnJvbSAnZnMnO1xuaW1wb3J0IHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBwYXJzZSB9IGZyb20gJ2Nzdi1wYXJzZS9zeW5jJztcblxudHlwZSBBbGdvcml0aG1LZXkgPSBzdHJpbmc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc1JlY29yZCB7XG4gIHNuYXBzaG90SWQ6IG51bWJlcjtcbiAgc3lzdGVtVGltZXN0YW1wOiBudW1iZXI7XG4gIHRpbWVzdGFtcDogc3RyaW5nO1xuICBwaWQ6IG51bWJlcjtcbiAgbmFtZTogc3RyaW5nO1xuICBzdGF0dXM6IHN0cmluZztcbiAgcHBpZDogbnVtYmVyIHwgbnVsbDtcbiAgY3B1UGVyY2VudDogbnVtYmVyO1xuICBtZW1vcnlQZXJjZW50OiBudW1iZXI7XG4gIG1lbW9yeU1iOiBudW1iZXI7XG4gIG51bVRocmVhZHM6IG51bWJlciB8IG51bGw7XG4gIG5pY2U6IG51bWJlciB8IG51bGw7XG4gIHByb2Nlc3NBZ2U6IG51bWJlciB8IG51bGw7XG4gIHByb2Nlc3NUeXBlOiBudW1iZXIgfCBudWxsO1xuICBpb0ludGVuc2l0eTogbnVtYmVyIHwgbnVsbDtcbiAgdXNlclRpbWU6IG51bWJlciB8IG51bGw7XG4gIHN5c3RlbVRpbWU6IG51bWJlciB8IG51bGw7XG4gIGJ1cnN0VGltZTogbnVtYmVyIHwgbnVsbDtcbiAgcHJlZGljdGVkQnVyc3RUaW1lOiBudW1iZXIgfCBudWxsO1xuICBhcnJpdmFsVGltZTogbnVtYmVyIHwgbnVsbDtcbiAgcHJlZGljdGVkVGltZVF1YW50dW06IG51bWJlciB8IG51bGw7XG4gIHByZWRpY3RlZFByaW9yaXR5OiBudW1iZXIgfCBudWxsO1xuICByZWNvbW1lbmRlZEFsZ29yaXRobTogQWxnb3JpdGhtS2V5O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NPdmVydmlldyB7XG4gIHBpZDogbnVtYmVyO1xuICB0YWc6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBhbGdvcml0aG06IEFsZ29yaXRobUtleTtcbiAgY3B1UGVyY2VudDogbnVtYmVyO1xuICBtZW1vcnlNYjogbnVtYmVyO1xuICBzdGF0dXM6IHN0cmluZztcbiAgcHJlZGljdGVkQnVyc3RUaW1lPzogbnVtYmVyIHwgbnVsbDtcbiAgcHJlZGljdGVkVGltZVF1YW50dW0/OiBudW1iZXIgfCBudWxsO1xuICBiZXN0QWxnb3JpdGhtPzogQWxnb3JpdGhtS2V5O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFByb2Nlc3NUYWJsZVJvdyB7XG4gIHBpZDogbnVtYmVyO1xuICB0YWc6IHN0cmluZztcbiAgbmFtZTogc3RyaW5nO1xuICBhcnJpdmFsVGltZTogbnVtYmVyO1xuICBidXJzdFRpbWU6IG51bWJlcjtcbiAgd2FpdGluZ1RpbWU6IG51bWJlcjtcbiAgdHVybmFyb3VuZFRpbWU6IG51bWJlcjtcbiAgY29tcGxldGlvblRpbWU6IG51bWJlcjtcbiAgY29sb3I6IHN0cmluZztcbiAgdGltZVF1YW50dW0/OiBudW1iZXIgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjaGVkdWxlU2VnbWVudCB7XG4gIHBpZDogbnVtYmVyIHwgbnVsbDtcbiAgdGFnOiBzdHJpbmc7XG4gIGxhYmVsOiBzdHJpbmc7XG4gIHN0YXJ0OiBudW1iZXI7XG4gIGVuZDogbnVtYmVyO1xuICBkdXJhdGlvbjogbnVtYmVyO1xuICBjb2xvcjogc3RyaW5nO1xuICBxdWV1ZUxldmVsPzogbnVtYmVyO1xuICB0aW1lUXVhbnR1bT86IG51bWJlciB8IG51bGw7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZWR1bGVNZXRyaWNzIHtcbiAgYXZlcmFnZUJ1cnN0VGltZTogbnVtYmVyO1xuICBhdmVyYWdlVHVybmFyb3VuZFRpbWU6IG51bWJlcjtcbiAgYXZlcmFnZVdhaXRpbmdUaW1lOiBudW1iZXI7XG4gIHRocm91Z2hwdXQ6IG51bWJlcjtcbiAgY3B1VXRpbGl6YXRpb246IG51bWJlcjtcbiAgbWFrZXNwYW46IG51bWJlcjtcbiAgdG90YWxCdXJzdDogbnVtYmVyO1xuICBpZGxlVGltZTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjaGVkdWxlUGF5bG9hZCB7XG4gIHNlZ21lbnRzOiBTY2hlZHVsZVNlZ21lbnRbXTtcbiAgdGFibGU6IFByb2Nlc3NUYWJsZVJvd1tdO1xuICBtZXRyaWNzOiBTY2hlZHVsZU1ldHJpY3M7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvY2Vzc2VzUGF5bG9hZCB7XG4gIGFsZ29yaXRobXM6IEFsZ29yaXRobVN1bW1hcnlbXTtcbiAgc2VsZWN0ZWRBbGdvcml0aG06IEFsZ29yaXRobUtleTtcbiAgYWxnb3JpdGhtRGVzY3JpcHRpb246IHN0cmluZztcbiAgcHJvY2Vzc2VzOiBQcm9jZXNzT3ZlcnZpZXdbXTtcbiAgc2NoZWR1bGU6IFNjaGVkdWxlUGF5bG9hZCB8IG51bGw7XG4gIGFsbFNjaGVkdWxlczogUmVjb3JkPEFsZ29yaXRobUtleSwgU2NoZWR1bGVQYXlsb2FkIHwgbnVsbD47XG4gIGxhc3RVcGRhdGVkOiBzdHJpbmcgfCBudWxsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFsZ29yaXRobVN1bW1hcnkge1xuICBuYW1lOiBBbGdvcml0aG1LZXk7XG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XG4gIGF2YWlsYWJsZTogYm9vbGVhbjtcbn1cblxuY29uc3QgQUxHT1JJVEhNX0RFU0NSSVBUSU9OUzogUmVjb3JkPEFsZ29yaXRobUtleSwgc3RyaW5nPiA9IHtcbiAgJ0ZpcnN0IENvbWUgRmlyc3QgU2VydmUgKEZDRlMpJzpcbiAgICAnUHJvY2Vzc2VzIGFyZSBleGVjdXRlZCBpbiB0aGUgb3JkZXIgdGhleSBhcnJpdmUuIFNpbXBsZSBidXQgY2FuIGxlYWQgdG8gbG9uZ2VyIHdhaXRpbmcgdGltZXMgZm9yIGxhdGVyIGpvYnMuJyxcbiAgJ1Nob3J0ZXN0IEpvYiBGaXJzdCAoU0pGKSc6XG4gICAgJ0Nob29zZXMgdGhlIHByb2Nlc3Mgd2l0aCB0aGUgc21hbGxlc3QgZXhlY3V0aW9uIHRpbWUgbmV4dC4gTWluaW1pemVzIGF2ZXJhZ2Ugd2FpdGluZyB0aW1lIGJ1dCByZXF1aXJlcyBrbm93aW5nIGJ1cnN0IGxlbmd0aHMuJyxcbiAgJ1Nob3J0ZXN0IFJlbWFpbmluZyBUaW1lIEZpcnN0IChTUlRGKSc6XG4gICAgJ1ByZWVtcHRpdmUgdmVyc2lvbiBvZiBTSkYgdGhhdCBhbHdheXMgcnVucyB0aGUgam9iIHdpdGggdGhlIGxlYXN0IHJlbWFpbmluZyB0aW1lLicsXG4gICdQcmlvcml0eSBTY2hlZHVsaW5nJzpcbiAgICAnRXhlY3V0ZXMgcHJvY2Vzc2VzIGJhc2VkIG9uIHByaW9yaXR5IGxldmVscy4gTG93ZXIgcHJpb3JpdHkgbnVtYmVycyBpbmRpY2F0ZSBoaWdoZXIgaW1wb3J0YW5jZSBieSBkZWZhdWx0LicsXG4gICdNdWx0aWxldmVsIEZlZWRiYWNrIFF1ZXVlIChNTEZRKSc6XG4gICAgJ1VzZXMgbXVsdGlwbGUgcXVldWVzIHdpdGggdmFyaWFibGUgcHJpb3JpdGllcyBhbmQgdGltZSBxdWFudHVtcywgYWRhcHRpbmcgdG8gcHJvY2VzcyBiZWhhdmlvciBvdmVyIHRpbWUuJ1xufTtcblxuY29uc3QgRVhDTFVERURfQUxHT1JJVEhNUyA9IG5ldyBTZXQ8QWxnb3JpdGhtS2V5PihbJ1JvdW5kIFJvYmluIChSUiknXSk7XG5cbmNvbnN0IERFRkFVTFRfREFUQV9GSUxFID0gcGF0aC5qb2luKHByb2Nlc3MuY3dkKCksICdzY2hlZHVsZXJfcmVzdWx0cyAoMSkuY3N2Jyk7XG5cbmNvbnN0IENPTE9SX1BBTEVUVEUgPSBbXG4gICcjZmY2MWQyJyxcbiAgJyM4NDVlYzInLFxuICAnI2Y5Zjg3MScsXG4gICcjZmY5NjcxJyxcbiAgJyMwMGM5YTcnLFxuICAnIzAwODFjZicsXG4gICcjZjI0YzAwJyxcbiAgJyNmZjZmOTEnLFxuICAnIzJjNzNkMicsXG4gICcjMDBjOWM4J1xuXTtcblxuaW50ZXJmYWNlIEludGVybmFsUHJvY2VzcyBleHRlbmRzIFByb2Nlc3NSZWNvcmQge1xuICByZW1haW5pbmdUaW1lOiBudW1iZXI7XG4gIG5vcm1hbGl6ZWRBcnJpdmFsOiBudW1iZXI7XG4gIHRhZzogc3RyaW5nO1xuICBjb2xvcjogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgU2ltdWxhdGlvblJlc3VsdCB7XG4gIHNlZ21lbnRzOiBTY2hlZHVsZVNlZ21lbnRbXTtcbiAgc3RhdHM6IE1hcDxzdHJpbmcsIHtcbiAgICBhcnJpdmFsOiBudW1iZXI7XG4gICAgYnVyc3Q6IG51bWJlcjtcbiAgICBjb21wbGV0aW9uOiBudW1iZXI7XG4gIH0+O1xuICBpZGxlVGltZTogbnVtYmVyO1xuICBtYWtlc3BhbjogbnVtYmVyO1xuICB0b3RhbEJ1cnN0OiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBudW1iZXIgfCBudWxsIHtcbiAgaWYgKCF2YWx1ZSB8fCB2YWx1ZS50cmltKCkgPT09ICcnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgbnVtID0gTnVtYmVyKHZhbHVlKTtcbiAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShudW0pID8gbnVtIDogbnVsbDtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZENzdlJlY29yZHMoKTogUHJvbWlzZTxQcm9jZXNzUmVjb3JkW10+IHtcbiAgY29uc3QgZmlsZVBhdGggPSBwcm9jZXNzLmVudi5TQ0hFRFVMRVJfREFUQV9GSUxFID8/IERFRkFVTFRfREFUQV9GSUxFO1xuICBjb25zdCBjb250ZW50ID0gYXdhaXQgZnMucmVhZEZpbGUoZmlsZVBhdGgsICd1dGY4Jyk7XG4gIGNvbnN0IHJlY29yZHMgPSBwYXJzZShjb250ZW50LCB7XG4gICAgY29sdW1uczogdHJ1ZSxcbiAgICBza2lwX2VtcHR5X2xpbmVzOiB0cnVlLFxuICAgIHRyaW06IHRydWVcbiAgfSkgYXMgUmVjb3JkPHN0cmluZywgc3RyaW5nPltdO1xuXG4gIGNvbnN0IGxhdGVzdEJ5UGlkID0gbmV3IE1hcDxudW1iZXIsIFByb2Nlc3NSZWNvcmQ+KCk7XG5cbiAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgIGNvbnN0IHBpZCA9IHRvTnVtYmVyKHJlY29yZC5waWQpO1xuICAgIGlmIChwaWQgPT09IG51bGwgfHwgcGlkID09PSAwIHx8IHBpZCA9PT0gNCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgY29uc3QgYnVyc3RUaW1lID0gdG9OdW1iZXIocmVjb3JkLmJ1cnN0X3RpbWUpID8/IHRvTnVtYmVyKHJlY29yZC5wcmVkaWN0ZWRfYnVyc3RfdGltZSk7XG4gICAgY29uc3QgYXJyaXZhbFRpbWUgPSB0b051bWJlcihyZWNvcmQuYXJyaXZhbF90aW1lKTtcbiAgICBjb25zdCBzeXN0ZW1UaW1lc3RhbXAgPSB0b051bWJlcihyZWNvcmQuc3lzdGVtX3RpbWVzdGFtcCkgPz8gMDtcblxuICAgIGNvbnN0IHBhcnNlZDogUHJvY2Vzc1JlY29yZCA9IHtcbiAgICAgIHNuYXBzaG90SWQ6IHRvTnVtYmVyKHJlY29yZC5zbmFwc2hvdF9pZCkgPz8gMCxcbiAgICAgIHN5c3RlbVRpbWVzdGFtcCxcbiAgICAgIHRpbWVzdGFtcDogcmVjb3JkLnRpbWVzdGFtcCxcbiAgICAgIHBpZCxcbiAgICAgIG5hbWU6IHJlY29yZC5uYW1lIHx8ICdVbmtub3duJyxcbiAgICAgIHN0YXR1czogcmVjb3JkLnN0YXR1cyB8fCAndW5rbm93bicsXG4gICAgICBwcGlkOiB0b051bWJlcihyZWNvcmQucHBpZCksXG4gICAgICBjcHVQZXJjZW50OiB0b051bWJlcihyZWNvcmQuY3B1X3BlcmNlbnQpID8/IDAsXG4gICAgICBtZW1vcnlQZXJjZW50OiB0b051bWJlcihyZWNvcmQubWVtb3J5X3BlcmNlbnQpID8/IDAsXG4gICAgICBtZW1vcnlNYjogdG9OdW1iZXIocmVjb3JkLm1lbW9yeV9tYikgPz8gMCxcbiAgICAgIG51bVRocmVhZHM6IHRvTnVtYmVyKHJlY29yZC5udW1fdGhyZWFkcyksXG4gICAgICBuaWNlOiB0b051bWJlcihyZWNvcmQubmljZSksXG4gICAgICBwcm9jZXNzQWdlOiB0b051bWJlcihyZWNvcmQucHJvY2Vzc19hZ2UpLFxuICAgICAgcHJvY2Vzc1R5cGU6IHRvTnVtYmVyKHJlY29yZC5wcm9jZXNzX3R5cGUpLFxuICAgICAgaW9JbnRlbnNpdHk6IHRvTnVtYmVyKHJlY29yZC5pb19pbnRlbnNpdHkpLFxuICAgICAgdXNlclRpbWU6IHRvTnVtYmVyKHJlY29yZC51c2VyX3RpbWUpLFxuICAgICAgc3lzdGVtVGltZTogdG9OdW1iZXIocmVjb3JkLnN5c3RlbV90aW1lKSxcbiAgICAgIGJ1cnN0VGltZSxcbiAgICAgIHByZWRpY3RlZEJ1cnN0VGltZTogdG9OdW1iZXIocmVjb3JkLnByZWRpY3RlZF9idXJzdF90aW1lKSxcbiAgICAgIGFycml2YWxUaW1lLFxuICAgICAgcHJlZGljdGVkVGltZVF1YW50dW06IHRvTnVtYmVyKHJlY29yZC5wcmVkaWN0ZWRfdGltZV9xdWFudHVtKSxcbiAgICAgIHByZWRpY3RlZFByaW9yaXR5OiB0b051bWJlcihyZWNvcmQucHJlZGljdGVkX3ByaW9yaXR5KSxcbiAgICAgIHJlY29tbWVuZGVkQWxnb3JpdGhtOiByZWNvcmQucmVjb21tZW5kZWRfYWxnb3JpdGhtIHx8ICdGaXJzdCBDb21lIEZpcnN0IFNlcnZlIChGQ0ZTKSdcbiAgICB9O1xuXG4gICAgaWYgKEVYQ0xVREVEX0FMR09SSVRITVMuaGFzKHBhcnNlZC5yZWNvbW1lbmRlZEFsZ29yaXRobSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IGV4aXN0aW5nID0gbGF0ZXN0QnlQaWQuZ2V0KHBpZCk7XG4gICAgaWYgKCFleGlzdGluZyB8fCBwYXJzZWQuc3lzdGVtVGltZXN0YW1wID49IGV4aXN0aW5nLnN5c3RlbVRpbWVzdGFtcCkge1xuICAgICAgbGF0ZXN0QnlQaWQuc2V0KHBpZCwgcGFyc2VkKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gWy4uLmxhdGVzdEJ5UGlkLnZhbHVlcygpXS5zb3J0KChhLCBiKSA9PiBhLnBpZCAtIGIucGlkKTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplUHJvY2Vzc2VzKHByb2Nlc3NlczogUHJvY2Vzc1JlY29yZFtdKTogSW50ZXJuYWxQcm9jZXNzW10ge1xuICBjb25zdCBhcnJpdmFsVmFsdWVzID0gcHJvY2Vzc2VzXG4gICAgLm1hcCgocCkgPT4gcC5hcnJpdmFsVGltZSlcbiAgICAuZmlsdGVyKCh2YWx1ZSk6IHZhbHVlIGlzIG51bWJlciA9PiB2YWx1ZSAhPT0gbnVsbCk7XG5cbiAgY29uc3QgbWluQXJyaXZhbCA9IGFycml2YWxWYWx1ZXMubGVuZ3RoID8gTWF0aC5taW4oLi4uYXJyaXZhbFZhbHVlcykgOiAwO1xuXG4gIHJldHVybiBwcm9jZXNzZXMubWFwKChwcm9jZXNzLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGJ1cnN0ID0gcHJvY2Vzcy5idXJzdFRpbWUgPz8gcHJvY2Vzcy5wcmVkaWN0ZWRCdXJzdFRpbWUgPz8gMDtcbiAgICBjb25zdCBhcnJpdmFsID0gcHJvY2Vzcy5hcnJpdmFsVGltZSA/PyBtaW5BcnJpdmFsO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRBcnJpdmFsID0gYXJyaXZhbCAtIG1pbkFycml2YWw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4ucHJvY2VzcyxcbiAgICAgIHJlbWFpbmluZ1RpbWU6IGJ1cnN0LFxuICAgICAgbm9ybWFsaXplZEFycml2YWwsXG4gICAgICB0YWc6IGBQJHtpbmRleCArIDF9YCxcbiAgICAgIGNvbG9yOiBDT0xPUl9QQUxFVFRFW2luZGV4ICUgQ09MT1JfUEFMRVRURS5sZW5ndGhdXG4gICAgfTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZElkbGVTZWdtZW50KFxuICBzZWdtZW50czogU2NoZWR1bGVTZWdtZW50W10sXG4gIGN1cnJlbnRUaW1lOiBudW1iZXIsXG4gIG5leHRUaW1lOiBudW1iZXJcbik6IHZvaWQge1xuICBpZiAobmV4dFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgc2VnbWVudHMucHVzaCh7XG4gICAgcGlkOiBudWxsLFxuICAgIHRhZzogJ0lETEUnLFxuICAgIGxhYmVsOiAnSWRsZScsXG4gICAgc3RhcnQ6IGN1cnJlbnRUaW1lLFxuICAgIGVuZDogbmV4dFRpbWUsXG4gICAgZHVyYXRpb246IG5leHRUaW1lIC0gY3VycmVudFRpbWUsXG4gICAgY29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMDgpJ1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc2ltdWxhdGVGQ0ZTKHByb2Nlc3NlczogSW50ZXJuYWxQcm9jZXNzW10pOiBTaW11bGF0aW9uUmVzdWx0IHtcbiAgY29uc3Qgc29ydGVkID0gWy4uLnByb2Nlc3Nlc10uc29ydCgoYSwgYikgPT4gYS5ub3JtYWxpemVkQXJyaXZhbCAtIGIubm9ybWFsaXplZEFycml2YWwpO1xuICBjb25zdCBzZWdtZW50czogU2NoZWR1bGVTZWdtZW50W10gPSBbXTtcbiAgY29uc3Qgc3RhdHMgPSBuZXcgTWFwPHN0cmluZywgeyBhcnJpdmFsOiBudW1iZXI7IGJ1cnN0OiBudW1iZXI7IGNvbXBsZXRpb246IG51bWJlciB9PigpO1xuXG4gIGxldCB0aW1lID0gMDtcbiAgY29uc3QgdG90YWxCdXJzdCA9IHNvcnRlZC5yZWR1Y2UoKGFjYywgcHJvYykgPT4gYWNjICsgKHByb2MuYnVyc3RUaW1lID8/IHByb2MucHJlZGljdGVkQnVyc3RUaW1lID8/IDApLCAwKTtcblxuICBmb3IgKGNvbnN0IHByb2Nlc3Mgb2Ygc29ydGVkKSB7XG4gICAgY29uc3QgYXJyaXZhbCA9IHByb2Nlc3Mubm9ybWFsaXplZEFycml2YWw7XG4gICAgaWYgKHRpbWUgPCBhcnJpdmFsKSB7XG4gICAgICBhZGRJZGxlU2VnbWVudChzZWdtZW50cywgdGltZSwgYXJyaXZhbCk7XG4gICAgICB0aW1lID0gYXJyaXZhbDtcbiAgICB9XG5cbiAgICBjb25zdCBidXJzdCA9IHByb2Nlc3MuYnVyc3RUaW1lID8/IHByb2Nlc3MucHJlZGljdGVkQnVyc3RUaW1lID8/IDA7XG4gICAgY29uc3Qgc3RhcnQgPSB0aW1lO1xuICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgYnVyc3Q7XG5cbiAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgIHBpZDogcHJvY2Vzcy5waWQsXG4gICAgICB0YWc6IHByb2Nlc3MudGFnLFxuICAgICAgbGFiZWw6IGAke3Byb2Nlc3MudGFnfWAsXG4gICAgICBzdGFydCxcbiAgICAgIGVuZCxcbiAgICAgIGR1cmF0aW9uOiBidXJzdCxcbiAgICAgIGNvbG9yOiBwcm9jZXNzLmNvbG9yXG4gICAgfSk7XG5cbiAgICB0aW1lID0gZW5kO1xuICAgIHN0YXRzLnNldChwcm9jZXNzLnRhZywge1xuICAgICAgYXJyaXZhbCxcbiAgICAgIGJ1cnN0LFxuICAgICAgY29tcGxldGlvbjogZW5kXG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBtYWtlc3BhbiA9IHNlZ21lbnRzLmxlbmd0aCA/IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLmVuZCA6IDA7XG4gIGNvbnN0IGlkbGVUaW1lID0gc2VnbWVudHNcbiAgICAuZmlsdGVyKChzZWdtZW50KSA9PiBzZWdtZW50LnBpZCA9PT0gbnVsbClcbiAgICAucmVkdWNlKChhY2MsIHNlZykgPT4gYWNjICsgc2VnLmR1cmF0aW9uLCAwKTtcblxuICByZXR1cm4geyBzZWdtZW50cywgc3RhdHMsIGlkbGVUaW1lLCBtYWtlc3BhbiwgdG90YWxCdXJzdCB9O1xufVxuXG5mdW5jdGlvbiBzaW11bGF0ZVByaW9yaXR5KHByb2Nlc3NlczogSW50ZXJuYWxQcm9jZXNzW10pOiBTaW11bGF0aW9uUmVzdWx0IHtcbiAgY29uc3Qgc2VnbWVudHM6IFNjaGVkdWxlU2VnbWVudFtdID0gW107XG4gIGNvbnN0IHN0YXRzID0gbmV3IE1hcDxzdHJpbmcsIHsgYXJyaXZhbDogbnVtYmVyOyBidXJzdDogbnVtYmVyOyBjb21wbGV0aW9uOiBudW1iZXIgfT4oKTtcbiAgY29uc3QgcmVtYWluaW5nID0gbmV3IE1hcChwcm9jZXNzZXMubWFwKChwKSA9PiBbcC50YWcsIHAuYnVyc3RUaW1lID8/IHAucHJlZGljdGVkQnVyc3RUaW1lID8/IDBdKSk7XG5cbiAgbGV0IHRpbWUgPSAwO1xuICBjb25zdCBzb3J0ZWRCeUFycml2YWwgPSBbLi4ucHJvY2Vzc2VzXS5zb3J0KChhLCBiKSA9PiBhLm5vcm1hbGl6ZWRBcnJpdmFsIC0gYi5ub3JtYWxpemVkQXJyaXZhbCk7XG4gIGNvbnN0IHRvdGFsQnVyc3QgPSBzb3J0ZWRCeUFycml2YWwucmVkdWNlKChhY2MsIHByb2MpID0+IGFjYyArIChwcm9jLmJ1cnN0VGltZSA/PyBwcm9jLnByZWRpY3RlZEJ1cnN0VGltZSA/PyAwKSwgMCk7XG5cbiAgY29uc3QgcmVhZHk6IEludGVybmFsUHJvY2Vzc1tdID0gW107XG4gIGxldCBpZHggPSAwO1xuXG4gIHdoaWxlIChzdGF0cy5zaXplIDwgcHJvY2Vzc2VzLmxlbmd0aCkge1xuICAgIHdoaWxlIChpZHggPCBzb3J0ZWRCeUFycml2YWwubGVuZ3RoICYmIHNvcnRlZEJ5QXJyaXZhbFtpZHhdLm5vcm1hbGl6ZWRBcnJpdmFsIDw9IHRpbWUpIHtcbiAgICAgIHJlYWR5LnB1c2goc29ydGVkQnlBcnJpdmFsW2lkeF0pO1xuICAgICAgaWR4ICs9IDE7XG4gICAgfVxuXG4gICAgaWYgKCFyZWFkeS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IG5leHRBcnJpdmFsID0gc29ydGVkQnlBcnJpdmFsW2lkeF0/Lm5vcm1hbGl6ZWRBcnJpdmFsO1xuICAgICAgaWYgKG5leHRBcnJpdmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBhZGRJZGxlU2VnbWVudChzZWdtZW50cywgdGltZSwgbmV4dEFycml2YWwpO1xuICAgICAgdGltZSA9IG5leHRBcnJpdmFsO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmVhZHkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgcHJpb3JpdHlBID0gYS5wcmVkaWN0ZWRQcmlvcml0eSA/PyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUjtcbiAgICAgIGNvbnN0IHByaW9yaXR5QiA9IGIucHJlZGljdGVkUHJpb3JpdHkgPz8gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICBpZiAocHJpb3JpdHlBID09PSBwcmlvcml0eUIpIHtcbiAgICAgICAgcmV0dXJuIGEubm9ybWFsaXplZEFycml2YWwgLSBiLm5vcm1hbGl6ZWRBcnJpdmFsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByaW9yaXR5QSAtIHByaW9yaXR5QjtcbiAgICB9KTtcblxuICAgIGNvbnN0IGN1cnJlbnQgPSByZWFkeS5zaGlmdCgpITtcbiAgICBjb25zdCBidXJzdCA9IHJlbWFpbmluZy5nZXQoY3VycmVudC50YWcpID8/IDA7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCh0aW1lLCBjdXJyZW50Lm5vcm1hbGl6ZWRBcnJpdmFsKTtcbiAgICBjb25zdCBlbmQgPSBzdGFydCArIGJ1cnN0O1xuXG4gICAgaWYgKHN0YXJ0ID4gdGltZSkge1xuICAgICAgYWRkSWRsZVNlZ21lbnQoc2VnbWVudHMsIHRpbWUsIHN0YXJ0KTtcbiAgICAgIHRpbWUgPSBzdGFydDtcbiAgICB9XG5cbiAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgIHBpZDogY3VycmVudC5waWQsXG4gICAgICB0YWc6IGN1cnJlbnQudGFnLFxuICAgICAgbGFiZWw6IGN1cnJlbnQudGFnLFxuICAgICAgc3RhcnQsXG4gICAgICBlbmQsXG4gICAgICBkdXJhdGlvbjogYnVyc3QsXG4gICAgICBjb2xvcjogY3VycmVudC5jb2xvclxuICAgIH0pO1xuXG4gICAgdGltZSA9IGVuZDtcbiAgICBzdGF0cy5zZXQoY3VycmVudC50YWcsIHtcbiAgICAgIGFycml2YWw6IGN1cnJlbnQubm9ybWFsaXplZEFycml2YWwsXG4gICAgICBidXJzdCxcbiAgICAgIGNvbXBsZXRpb246IGVuZFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgbWFrZXNwYW4gPSBzZWdtZW50cy5sZW5ndGggPyBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5lbmQgOiAwO1xuICBjb25zdCBpZGxlVGltZSA9IHNlZ21lbnRzXG4gICAgLmZpbHRlcigoc2VnbWVudCkgPT4gc2VnbWVudC5waWQgPT09IG51bGwpXG4gICAgLnJlZHVjZSgoYWNjLCBzZWcpID0+IGFjYyArIHNlZy5kdXJhdGlvbiwgMCk7XG5cbiAgcmV0dXJuIHsgc2VnbWVudHMsIHN0YXRzLCBpZGxlVGltZSwgbWFrZXNwYW4sIHRvdGFsQnVyc3QgfTtcbn1cblxuZnVuY3Rpb24gc2ltdWxhdGVNTEZRKHByb2Nlc3NlczogSW50ZXJuYWxQcm9jZXNzW10pOiBTaW11bGF0aW9uUmVzdWx0IHtcbiAgY29uc3QgcXVhbnR1bXMgPSBbNCwgOCwgMTZdO1xuICBjb25zdCBxdWV1ZXM6IEludGVybmFsUHJvY2Vzc1tdW10gPSBbW10sIFtdLCBbXV07XG4gIGNvbnN0IHN0YXRzID0gbmV3IE1hcDxzdHJpbmcsIHsgYXJyaXZhbDogbnVtYmVyOyBidXJzdDogbnVtYmVyOyBjb21wbGV0aW9uOiBudW1iZXIgfT4oKTtcbiAgY29uc3QgcmVtYWluaW5nID0gbmV3IE1hcChwcm9jZXNzZXMubWFwKChwKSA9PiBbcC50YWcsIHAuYnVyc3RUaW1lID8/IHAucHJlZGljdGVkQnVyc3RUaW1lID8/IDBdKSk7XG4gIGNvbnN0IHNlZ21lbnRzOiBTY2hlZHVsZVNlZ21lbnRbXSA9IFtdO1xuXG4gIGNvbnN0IHNvcnRlZCA9IFsuLi5wcm9jZXNzZXNdLnNvcnQoKGEsIGIpID0+IGEubm9ybWFsaXplZEFycml2YWwgLSBiLm5vcm1hbGl6ZWRBcnJpdmFsKTtcbiAgY29uc3QgdG90YWxCdXJzdCA9IHNvcnRlZC5yZWR1Y2UoKGFjYywgcHJvYykgPT4gYWNjICsgKHByb2MuYnVyc3RUaW1lID8/IHByb2MucHJlZGljdGVkQnVyc3RUaW1lID8/IDApLCAwKTtcblxuICBsZXQgdGltZSA9IDA7XG4gIGxldCBpZHggPSAwO1xuXG4gIGNvbnN0IGVucXVldWVOZXdBcnJpdmFscyA9ICgpID0+IHtcbiAgICB3aGlsZSAoaWR4IDwgc29ydGVkLmxlbmd0aCAmJiBzb3J0ZWRbaWR4XS5ub3JtYWxpemVkQXJyaXZhbCA8PSB0aW1lKSB7XG4gICAgICBxdWV1ZXNbMF0ucHVzaChzb3J0ZWRbaWR4XSk7XG4gICAgICBpZHggKz0gMTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgaGFzUmVhZHkgPSAoKSA9PiBxdWV1ZXMuc29tZSgocSkgPT4gcS5sZW5ndGggPiAwKTtcblxuICB3aGlsZSAoc3RhdHMuc2l6ZSA8IHByb2Nlc3Nlcy5sZW5ndGgpIHtcbiAgICBlbnF1ZXVlTmV3QXJyaXZhbHMoKTtcblxuICAgIGlmICghaGFzUmVhZHkoKSkge1xuICAgICAgY29uc3QgbmV4dEFycml2YWwgPSBzb3J0ZWRbaWR4XT8ubm9ybWFsaXplZEFycml2YWw7XG4gICAgICBpZiAobmV4dEFycml2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGFkZElkbGVTZWdtZW50KHNlZ21lbnRzLCB0aW1lLCBuZXh0QXJyaXZhbCk7XG4gICAgICB0aW1lID0gbmV4dEFycml2YWw7XG4gICAgICBlbnF1ZXVlTmV3QXJyaXZhbHMoKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGxldCBsZXZlbCA9IHF1ZXVlcy5maW5kSW5kZXgoKHEpID0+IHEubGVuZ3RoID4gMCk7XG4gICAgaWYgKGxldmVsID09PSAtMSkge1xuICAgICAgbGV2ZWwgPSBxdWV1ZXMubGVuZ3RoIC0gMTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50ID0gcXVldWVzW2xldmVsXS5zaGlmdCgpITtcbiAgICBjb25zdCByZW1haW5pbmdUaW1lID0gcmVtYWluaW5nLmdldChjdXJyZW50LnRhZykgPz8gMDtcbiAgICBjb25zdCBxdWFudHVtID0gcXVhbnR1bXNbbGV2ZWxdID8/IHF1YW50dW1zW3F1YW50dW1zLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHByZWRpY3RlZFF1YW50dW0gPSBjdXJyZW50LnByZWRpY3RlZFRpbWVRdWFudHVtID8/IHF1YW50dW07XG4gICAgY29uc3QgYWN0dWFsUnVuID0gTWF0aC5taW4ocXVhbnR1bSwgcmVtYWluaW5nVGltZSk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLm1heCh0aW1lLCBjdXJyZW50Lm5vcm1hbGl6ZWRBcnJpdmFsKTtcblxuICAgIGlmIChzdGFydCA+IHRpbWUpIHtcbiAgICAgIGFkZElkbGVTZWdtZW50KHNlZ21lbnRzLCB0aW1lLCBzdGFydCk7XG4gICAgICB0aW1lID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgY29uc3QgZW5kID0gdGltZSArIGFjdHVhbFJ1bjtcblxuICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgcGlkOiBjdXJyZW50LnBpZCxcbiAgICAgIHRhZzogY3VycmVudC50YWcsXG4gICAgICBsYWJlbDogYCR7Y3VycmVudC50YWd9IChRJHtsZXZlbCArIDF9KWAsXG4gICAgICBzdGFydDogdGltZSxcbiAgICAgIGVuZCxcbiAgICAgIGR1cmF0aW9uOiBhY3R1YWxSdW4sXG4gICAgICBjb2xvcjogY3VycmVudC5jb2xvcixcbiAgICAgIHF1ZXVlTGV2ZWw6IGxldmVsICsgMSxcbiAgICAgIHRpbWVRdWFudHVtOiBwcmVkaWN0ZWRRdWFudHVtXG4gICAgfSk7XG5cbiAgICB0aW1lID0gZW5kO1xuICAgIGVucXVldWVOZXdBcnJpdmFscygpO1xuXG4gICAgY29uc3QgdXBkYXRlZFJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgLSBhY3R1YWxSdW47XG4gICAgcmVtYWluaW5nLnNldChjdXJyZW50LnRhZywgdXBkYXRlZFJlbWFpbmluZyk7XG5cbiAgICBpZiAodXBkYXRlZFJlbWFpbmluZyA+IDAuMDAwMSkge1xuICAgICAgY29uc3QgbmV4dExldmVsID0gTWF0aC5taW4obGV2ZWwgKyAxLCBxdWV1ZXMubGVuZ3RoIC0gMSk7XG4gICAgICBxdWV1ZXNbbmV4dExldmVsXS5wdXNoKGN1cnJlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBidXJzdCA9IGN1cnJlbnQuYnVyc3RUaW1lID8/IGN1cnJlbnQucHJlZGljdGVkQnVyc3RUaW1lID8/IDA7XG4gICAgICBzdGF0cy5zZXQoY3VycmVudC50YWcsIHtcbiAgICAgICAgYXJyaXZhbDogY3VycmVudC5ub3JtYWxpemVkQXJyaXZhbCxcbiAgICAgICAgYnVyc3QsXG4gICAgICAgIGNvbXBsZXRpb246IHRpbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1ha2VzcGFuID0gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uZW5kIDogMDtcbiAgY29uc3QgaWRsZVRpbWUgPSBzZWdtZW50c1xuICAgIC5maWx0ZXIoKHNlZ21lbnQpID0+IHNlZ21lbnQucGlkID09PSBudWxsKVxuICAgIC5yZWR1Y2UoKGFjYywgc2VnKSA9PiBhY2MgKyBzZWcuZHVyYXRpb24sIDApO1xuXG4gIHJldHVybiB7IHNlZ21lbnRzLCBzdGF0cywgaWRsZVRpbWUsIG1ha2VzcGFuLCB0b3RhbEJ1cnN0IH07XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgc2NoZWR1bGluZyBtZXRyaWNzIGZvciBhbGwgcHJvY2Vzc2VzXG4gKiBcbiAqIE1FVFJJQ1MgQ0FMQ1VMQVRJT04gRVhQTEFOQVRJT046XG4gKiBcbiAqIDEuIEF2ZXJhZ2UgV2FpdGluZyBUaW1lOlxuICogICAgLSBGb3IgZWFjaCBwcm9jZXNzOiBXYWl0aW5nIFRpbWUgPSBDb21wbGV0aW9uIFRpbWUgLSBBcnJpdmFsIFRpbWUgLSBCdXJzdCBUaW1lXG4gKiAgICAtIEF2ZXJhZ2UgPSBTdW0gb2YgYWxsIHdhaXRpbmcgdGltZXMgLyBOdW1iZXIgb2YgcHJvY2Vzc2VzXG4gKiAgICAtIFRoaXMgbWVhc3VyZXMgaG93IGxvbmcgcHJvY2Vzc2VzIHdhaXQgaW4gdGhlIHJlYWR5IHF1ZXVlIGJlZm9yZSBleGVjdXRpb25cbiAqIFxuICogMi4gQXZlcmFnZSBUdXJuYXJvdW5kIFRpbWU6XG4gKiAgICAtIEZvciBlYWNoIHByb2Nlc3M6IFR1cm5hcm91bmQgVGltZSA9IENvbXBsZXRpb24gVGltZSAtIEFycml2YWwgVGltZVxuICogICAgLSBBdmVyYWdlID0gU3VtIG9mIGFsbCB0dXJuYXJvdW5kIHRpbWVzIC8gTnVtYmVyIG9mIHByb2Nlc3Nlc1xuICogICAgLSBUaGlzIG1lYXN1cmVzIHRvdGFsIHRpbWUgZnJvbSBhcnJpdmFsIHRvIGNvbXBsZXRpb24gKHdhaXRpbmcgKyBleGVjdXRpb24pXG4gKiBcbiAqIDMuIEF2ZXJhZ2UgQnVyc3QgVGltZTpcbiAqICAgIC0gQXZlcmFnZSA9IFN1bSBvZiBhbGwgYnVyc3QgdGltZXMgLyBOdW1iZXIgb2YgcHJvY2Vzc2VzXG4gKiAgICAtIFRoaXMgaXMgdGhlIGF2ZXJhZ2UgZXhlY3V0aW9uIHRpbWUgbmVlZGVkIGJ5IHByb2Nlc3Nlc1xuICogXG4gKiA0LiBUaHJvdWdocHV0OlxuICogICAgLSBUaHJvdWdocHV0ID0gTnVtYmVyIG9mIHByb2Nlc3NlcyBjb21wbGV0ZWQgLyBNYWtlc3BhblxuICogICAgLSBNZWFzdXJlcyBob3cgbWFueSBwcm9jZXNzZXMgY29tcGxldGUgcGVyIHVuaXQgdGltZVxuICogXG4gKiA1LiBDUFUgVXRpbGl6YXRpb246XG4gKiAgICAtIEJ1c3kgVGltZSA9IE1ha2VzcGFuIC0gSWRsZSBUaW1lXG4gKiAgICAtIENQVSBVdGlsaXphdGlvbiA9IChCdXN5IFRpbWUgLyBNYWtlc3BhbikgKiAxMDAlXG4gKiAgICAtIE1lYXN1cmVzIHBlcmNlbnRhZ2Ugb2YgdGltZSBDUFUgaXMgYnVzeSBleGVjdXRpbmcgcHJvY2Vzc2VzXG4gKiBcbiAqIDYuIE1ha2VzcGFuOlxuICogICAgLSBNYWtlc3BhbiA9IEVuZCB0aW1lIG9mIHRoZSBsYXN0IHNlZ21lbnQgKHRvdGFsIHRpbWUgdG8gY29tcGxldGUgYWxsIHByb2Nlc3NlcylcbiAqIFxuICogNy4gSWRsZSBUaW1lOlxuICogICAgLSBTdW0gb2YgYWxsIGlkbGUgc2VnbWVudHMgKHRpbWUgd2hlbiBDUFUgaGFzIG5vIHByb2Nlc3NlcyB0byBleGVjdXRlKVxuICovXG5mdW5jdGlvbiBjb21wdXRlTWV0cmljcyhcbiAgc3RhdHM6IE1hcDxzdHJpbmcsIHsgYXJyaXZhbDogbnVtYmVyOyBidXJzdDogbnVtYmVyOyBjb21wbGV0aW9uOiBudW1iZXIgfT4sXG4gIHNlZ21lbnRzOiBTY2hlZHVsZVNlZ21lbnRbXSxcbiAgdG90YWxCdXJzdDogbnVtYmVyLFxuICBpZGxlVGltZTogbnVtYmVyXG4pOiBTY2hlZHVsZU1ldHJpY3Mge1xuICBjb25zdCB2YWx1ZXMgPSBbLi4uc3RhdHMudmFsdWVzKCldO1xuICBpZiAoIXZhbHVlcy5sZW5ndGgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYXZlcmFnZUJ1cnN0VGltZTogMCxcbiAgICAgIGF2ZXJhZ2VUdXJuYXJvdW5kVGltZTogMCxcbiAgICAgIGF2ZXJhZ2VXYWl0aW5nVGltZTogMCxcbiAgICAgIHRocm91Z2hwdXQ6IDAsXG4gICAgICBjcHVVdGlsaXphdGlvbjogMCxcbiAgICAgIG1ha2VzcGFuOiAwLFxuICAgICAgdG90YWxCdXJzdDogMCxcbiAgICAgIGlkbGVUaW1lOiAwXG4gICAgfTtcbiAgfVxuXG4gIC8vIE1ha2VzcGFuID0gdG90YWwgdGltZSBmcm9tIHN0YXJ0IHRvIGZpbmlzaCBvZiBhbGwgcHJvY2Vzc2VzXG4gIGNvbnN0IG1ha2VzcGFuID0gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uZW5kIDogMDtcblxuICAvLyBUdXJuYXJvdW5kIFRpbWUgPSBDb21wbGV0aW9uIFRpbWUgLSBBcnJpdmFsIFRpbWUgKHRvdGFsIHRpbWUgaW4gc3lzdGVtKVxuICBjb25zdCB0b3RhbFR1cm5hcm91bmQgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHsgYXJyaXZhbCwgY29tcGxldGlvbiB9KSA9PiBhY2MgKyAoY29tcGxldGlvbiAtIGFycml2YWwpLCAwKTtcbiAgXG4gIC8vIFdhaXRpbmcgVGltZSA9IENvbXBsZXRpb24gVGltZSAtIEFycml2YWwgVGltZSAtIEJ1cnN0IFRpbWUgKHRpbWUgc3BlbnQgd2FpdGluZylcbiAgY29uc3QgdG90YWxXYWl0aW5nID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB7IGFycml2YWwsIGNvbXBsZXRpb24sIGJ1cnN0IH0pID0+IGFjYyArIChjb21wbGV0aW9uIC0gYXJyaXZhbCAtIGJ1cnN0KSwgMCk7XG4gIFxuICAvLyBBdmVyYWdlIEJ1cnN0IFRpbWUgPSBTdW0gb2YgYnVyc3QgdGltZXMgLyBOdW1iZXIgb2YgcHJvY2Vzc2VzXG4gIGNvbnN0IGF2Z0J1cnN0ID0gdmFsdWVzLnJlZHVjZSgoYWNjLCB7IGJ1cnN0IH0pID0+IGFjYyArIGJ1cnN0LCAwKSAvIHZhbHVlcy5sZW5ndGg7XG5cbiAgLy8gVGhyb3VnaHB1dCA9IE51bWJlciBvZiBwcm9jZXNzZXMgLyBUb3RhbCB0aW1lIChwcm9jZXNzZXMgcGVyIHVuaXQgdGltZSlcbiAgY29uc3QgdGhyb3VnaHB1dCA9IG1ha2VzcGFuID4gMCA/IHZhbHVlcy5sZW5ndGggLyBtYWtlc3BhbiA6IDA7XG4gIFxuICAvLyBCdXN5IFRpbWUgPSBUb3RhbCB0aW1lIC0gSWRsZSB0aW1lICh0aW1lIENQVSB3YXMgZXhlY3V0aW5nIHByb2Nlc3NlcylcbiAgY29uc3QgYnVzeVRpbWUgPSBNYXRoLm1heChtYWtlc3BhbiAtIGlkbGVUaW1lLCAwKTtcbiAgXG4gIC8vIENQVSBVdGlsaXphdGlvbiA9IChCdXN5IFRpbWUgLyBUb3RhbCBUaW1lKSAqIDEwMCVcbiAgY29uc3QgY3B1VXRpbGl6YXRpb24gPSBtYWtlc3BhbiA+IDAgPyAoYnVzeVRpbWUgLyBtYWtlc3BhbikgKiAxMDAgOiAwO1xuXG4gIHJldHVybiB7XG4gICAgYXZlcmFnZUJ1cnN0VGltZTogYXZnQnVyc3QsXG4gICAgYXZlcmFnZVR1cm5hcm91bmRUaW1lOiB0b3RhbFR1cm5hcm91bmQgLyB2YWx1ZXMubGVuZ3RoLFxuICAgIGF2ZXJhZ2VXYWl0aW5nVGltZTogdG90YWxXYWl0aW5nIC8gdmFsdWVzLmxlbmd0aCxcbiAgICB0aHJvdWdocHV0LFxuICAgIGNwdVV0aWxpemF0aW9uLFxuICAgIG1ha2VzcGFuLFxuICAgIHRvdGFsQnVyc3QsXG4gICAgaWRsZVRpbWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRUYWJsZShcbiAgc3RhdHM6IE1hcDxzdHJpbmcsIHsgYXJyaXZhbDogbnVtYmVyOyBidXJzdDogbnVtYmVyOyBjb21wbGV0aW9uOiBudW1iZXIgfT4sXG4gIHByb2Nlc3NlczogSW50ZXJuYWxQcm9jZXNzW10sXG4gIGNvbG9yQnlUYWc6IE1hcDxzdHJpbmcsIHN0cmluZz5cbik6IFByb2Nlc3NUYWJsZVJvd1tdIHtcbiAgY29uc3QgdGFnVG9Qcm9jZXNzID0gbmV3IE1hcChwcm9jZXNzZXMubWFwKChwcm9jKSA9PiBbcHJvYy50YWcsIHByb2NdKSk7XG5cbiAgcmV0dXJuIFsuLi5zdGF0cy5lbnRyaWVzKCldXG4gICAgLm1hcCgoW3RhZywgeyBhcnJpdmFsLCBidXJzdCwgY29tcGxldGlvbiB9XSkgPT4ge1xuICAgICAgY29uc3QgcHJvY2VzcyA9IHRhZ1RvUHJvY2Vzcy5nZXQodGFnKTtcbiAgICAgIGlmICghcHJvY2Vzcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgcHJvY2VzcyBmb3IgdGFnICR7dGFnfWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBwaWQ6IHByb2Nlc3MucGlkLFxuICAgICAgICB0YWcsXG4gICAgICAgIG5hbWU6IHByb2Nlc3MubmFtZSxcbiAgICAgICAgYXJyaXZhbFRpbWU6IE51bWJlcihhcnJpdmFsLnRvRml4ZWQoMikpLFxuICAgICAgICBidXJzdFRpbWU6IE51bWJlcihidXJzdC50b0ZpeGVkKDIpKSxcbiAgICAgICAgd2FpdGluZ1RpbWU6IE51bWJlcigoY29tcGxldGlvbiAtIGFycml2YWwgLSBidXJzdCkudG9GaXhlZCgyKSksXG4gICAgICAgIHR1cm5hcm91bmRUaW1lOiBOdW1iZXIoKGNvbXBsZXRpb24gLSBhcnJpdmFsKS50b0ZpeGVkKDIpKSxcbiAgICAgICAgY29tcGxldGlvblRpbWU6IE51bWJlcihjb21wbGV0aW9uLnRvRml4ZWQoMikpLFxuICAgICAgICBjb2xvcjogY29sb3JCeVRhZy5nZXQodGFnKSA/PyAnIzk5OScsXG4gICAgICAgIHRpbWVRdWFudHVtOiBwcm9jZXNzLnByZWRpY3RlZFRpbWVRdWFudHVtID8/IG51bGxcbiAgICAgIH07XG4gICAgfSlcbiAgICAuc29ydCgoYSwgYikgPT4gYS5hcnJpdmFsVGltZSAtIGIuYXJyaXZhbFRpbWUpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRTZWdtZW50cyhzZWdtZW50czogU2NoZWR1bGVTZWdtZW50W10pOiBTY2hlZHVsZVNlZ21lbnRbXSB7XG4gIHJldHVybiBzZWdtZW50cy5tYXAoKHNlZ21lbnQpID0+ICh7XG4gICAgLi4uc2VnbWVudCxcbiAgICBzdGFydDogTnVtYmVyKHNlZ21lbnQuc3RhcnQudG9GaXhlZCgyKSksXG4gICAgZW5kOiBOdW1iZXIoc2VnbWVudC5lbmQudG9GaXhlZCgyKSksXG4gICAgZHVyYXRpb246IE51bWJlcihzZWdtZW50LmR1cmF0aW9uLnRvRml4ZWQoMikpXG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gc2ltdWxhdGVTSkYocHJvY2Vzc2VzOiBJbnRlcm5hbFByb2Nlc3NbXSk6IFNpbXVsYXRpb25SZXN1bHQge1xuICBjb25zdCBzb3J0ZWQgPSBbLi4ucHJvY2Vzc2VzXS5zb3J0KChhLCBiKSA9PiB7XG4gICAgY29uc3QgYnVyc3RBID0gYS5idXJzdFRpbWUgPz8gYS5wcmVkaWN0ZWRCdXJzdFRpbWUgPz8gMDtcbiAgICBjb25zdCBidXJzdEIgPSBiLmJ1cnN0VGltZSA/PyBiLnByZWRpY3RlZEJ1cnN0VGltZSA/PyAwO1xuICAgIGlmIChNYXRoLmFicyhidXJzdEEgLSBidXJzdEIpIDwgMC4wMDEpIHtcbiAgICAgIHJldHVybiBhLm5vcm1hbGl6ZWRBcnJpdmFsIC0gYi5ub3JtYWxpemVkQXJyaXZhbDtcbiAgICB9XG4gICAgcmV0dXJuIGJ1cnN0QSAtIGJ1cnN0QjtcbiAgfSk7XG4gIGNvbnN0IHNlZ21lbnRzOiBTY2hlZHVsZVNlZ21lbnRbXSA9IFtdO1xuICBjb25zdCBzdGF0cyA9IG5ldyBNYXA8c3RyaW5nLCB7IGFycml2YWw6IG51bWJlcjsgYnVyc3Q6IG51bWJlcjsgY29tcGxldGlvbjogbnVtYmVyIH0+KCk7XG5cbiAgbGV0IHRpbWUgPSAwO1xuICBjb25zdCB0b3RhbEJ1cnN0ID0gc29ydGVkLnJlZHVjZSgoYWNjLCBwcm9jKSA9PiBhY2MgKyAocHJvYy5idXJzdFRpbWUgPz8gcHJvYy5wcmVkaWN0ZWRCdXJzdFRpbWUgPz8gMCksIDApO1xuXG4gIGZvciAoY29uc3QgcHJvY2VzcyBvZiBzb3J0ZWQpIHtcbiAgICBjb25zdCBhcnJpdmFsID0gcHJvY2Vzcy5ub3JtYWxpemVkQXJyaXZhbDtcbiAgICBpZiAodGltZSA8IGFycml2YWwpIHtcbiAgICAgIGFkZElkbGVTZWdtZW50KHNlZ21lbnRzLCB0aW1lLCBhcnJpdmFsKTtcbiAgICAgIHRpbWUgPSBhcnJpdmFsO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1cnN0ID0gcHJvY2Vzcy5idXJzdFRpbWUgPz8gcHJvY2Vzcy5wcmVkaWN0ZWRCdXJzdFRpbWUgPz8gMDtcbiAgICBjb25zdCBzdGFydCA9IHRpbWU7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBidXJzdDtcblxuICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgcGlkOiBwcm9jZXNzLnBpZCxcbiAgICAgIHRhZzogcHJvY2Vzcy50YWcsXG4gICAgICBsYWJlbDogYCR7cHJvY2Vzcy50YWd9YCxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kLFxuICAgICAgZHVyYXRpb246IGJ1cnN0LFxuICAgICAgY29sb3I6IHByb2Nlc3MuY29sb3JcbiAgICB9KTtcblxuICAgIHRpbWUgPSBlbmQ7XG4gICAgc3RhdHMuc2V0KHByb2Nlc3MudGFnLCB7XG4gICAgICBhcnJpdmFsLFxuICAgICAgYnVyc3QsXG4gICAgICBjb21wbGV0aW9uOiBlbmRcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0IG1ha2VzcGFuID0gc2VnbWVudHMubGVuZ3RoID8gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uZW5kIDogMDtcbiAgY29uc3QgaWRsZVRpbWUgPSBzZWdtZW50c1xuICAgIC5maWx0ZXIoKHNlZ21lbnQpID0+IHNlZ21lbnQucGlkID09PSBudWxsKVxuICAgIC5yZWR1Y2UoKGFjYywgc2VnKSA9PiBhY2MgKyBzZWcuZHVyYXRpb24sIDApO1xuXG4gIHJldHVybiB7IHNlZ21lbnRzLCBzdGF0cywgaWRsZVRpbWUsIG1ha2VzcGFuLCB0b3RhbEJ1cnN0IH07XG59XG5cbmZ1bmN0aW9uIHNpbXVsYXRlU1JURihwcm9jZXNzZXM6IEludGVybmFsUHJvY2Vzc1tdKTogU2ltdWxhdGlvblJlc3VsdCB7XG4gIGNvbnN0IHNlZ21lbnRzOiBTY2hlZHVsZVNlZ21lbnRbXSA9IFtdO1xuICBjb25zdCBzdGF0cyA9IG5ldyBNYXA8c3RyaW5nLCB7IGFycml2YWw6IG51bWJlcjsgYnVyc3Q6IG51bWJlcjsgY29tcGxldGlvbjogbnVtYmVyIH0+KCk7XG4gIGNvbnN0IHJlbWFpbmluZyA9IG5ldyBNYXAocHJvY2Vzc2VzLm1hcCgocCkgPT4gW3AudGFnLCBwLmJ1cnN0VGltZSA/PyBwLnByZWRpY3RlZEJ1cnN0VGltZSA/PyAwXSkpO1xuXG4gIGxldCB0aW1lID0gMDtcbiAgY29uc3Qgc29ydGVkQnlBcnJpdmFsID0gWy4uLnByb2Nlc3Nlc10uc29ydCgoYSwgYikgPT4gYS5ub3JtYWxpemVkQXJyaXZhbCAtIGIubm9ybWFsaXplZEFycml2YWwpO1xuICBjb25zdCB0b3RhbEJ1cnN0ID0gc29ydGVkQnlBcnJpdmFsLnJlZHVjZSgoYWNjLCBwcm9jKSA9PiBhY2MgKyAocHJvYy5idXJzdFRpbWUgPz8gcHJvYy5wcmVkaWN0ZWRCdXJzdFRpbWUgPz8gMCksIDApO1xuXG4gIGNvbnN0IHJlYWR5OiBJbnRlcm5hbFByb2Nlc3NbXSA9IFtdO1xuICBsZXQgaWR4ID0gMDtcblxuICB3aGlsZSAoc3RhdHMuc2l6ZSA8IHByb2Nlc3Nlcy5sZW5ndGgpIHtcbiAgICAvLyBBZGQgbmV3bHkgYXJyaXZlZCBwcm9jZXNzZXNcbiAgICB3aGlsZSAoaWR4IDwgc29ydGVkQnlBcnJpdmFsLmxlbmd0aCAmJiBzb3J0ZWRCeUFycml2YWxbaWR4XS5ub3JtYWxpemVkQXJyaXZhbCA8PSB0aW1lKSB7XG4gICAgICByZWFkeS5wdXNoKHNvcnRlZEJ5QXJyaXZhbFtpZHhdKTtcbiAgICAgIGlkeCArPSAxO1xuICAgIH1cblxuICAgIGlmICghcmVhZHkubGVuZ3RoKSB7XG4gICAgICBjb25zdCBuZXh0QXJyaXZhbCA9IHNvcnRlZEJ5QXJyaXZhbFtpZHhdPy5ub3JtYWxpemVkQXJyaXZhbDtcbiAgICAgIGlmIChuZXh0QXJyaXZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgYWRkSWRsZVNlZ21lbnQoc2VnbWVudHMsIHRpbWUsIG5leHRBcnJpdmFsKTtcbiAgICAgIHRpbWUgPSBuZXh0QXJyaXZhbDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFNvcnQgYnkgcmVtYWluaW5nIHRpbWUgKFNSVEYpXG4gICAgcmVhZHkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgY29uc3QgcmVtYWluaW5nQSA9IHJlbWFpbmluZy5nZXQoYS50YWcpID8/IDA7XG4gICAgICBjb25zdCByZW1haW5pbmdCID0gcmVtYWluaW5nLmdldChiLnRhZykgPz8gMDtcbiAgICAgIGlmIChNYXRoLmFicyhyZW1haW5pbmdBIC0gcmVtYWluaW5nQikgPCAwLjAwMSkge1xuICAgICAgICByZXR1cm4gYS5ub3JtYWxpemVkQXJyaXZhbCAtIGIubm9ybWFsaXplZEFycml2YWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtYWluaW5nQSAtIHJlbWFpbmluZ0I7XG4gICAgfSk7XG5cbiAgICBjb25zdCBjdXJyZW50ID0gcmVhZHlbMF07XG4gICAgY29uc3QgcmVtYWluaW5nVGltZSA9IHJlbWFpbmluZy5nZXQoY3VycmVudC50YWcpID8/IDA7XG4gICAgXG4gICAgLy8gRmluZCBuZXh0IGV2ZW50OiBlaXRoZXIgbmV4dCBhcnJpdmFsIG9yIGNvbXBsZXRpb25cbiAgICBjb25zdCBuZXh0QXJyaXZhbCA9IHNvcnRlZEJ5QXJyaXZhbFtpZHhdPy5ub3JtYWxpemVkQXJyaXZhbDtcbiAgICBjb25zdCB0aW1lVW50aWxOZXh0ID0gbmV4dEFycml2YWwgIT09IHVuZGVmaW5lZCA/IG5leHRBcnJpdmFsIC0gdGltZSA6IEluZmluaXR5O1xuICAgIGNvbnN0IHJ1blRpbWUgPSBNYXRoLm1pbihyZW1haW5pbmdUaW1lLCB0aW1lVW50aWxOZXh0KTtcbiAgICBcbiAgICBjb25zdCBzdGFydCA9IHRpbWU7XG4gICAgY29uc3QgZW5kID0gc3RhcnQgKyBydW5UaW1lO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2Ugc2hvdWxkIG1lcmdlIHdpdGggcHJldmlvdXMgc2VnbWVudFxuICAgIGNvbnN0IGxhc3RTZWdtZW50ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKGxhc3RTZWdtZW50ICYmIGxhc3RTZWdtZW50LnBpZCA9PT0gY3VycmVudC5waWQgJiYgTWF0aC5hYnMobGFzdFNlZ21lbnQuZW5kIC0gc3RhcnQpIDwgMC4wMDAxKSB7XG4gICAgICBsYXN0U2VnbWVudC5lbmQgPSBlbmQ7XG4gICAgICBsYXN0U2VnbWVudC5kdXJhdGlvbiArPSBydW5UaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgcGlkOiBjdXJyZW50LnBpZCxcbiAgICAgICAgdGFnOiBjdXJyZW50LnRhZyxcbiAgICAgICAgbGFiZWw6IGN1cnJlbnQudGFnLFxuICAgICAgICBzdGFydCxcbiAgICAgICAgZW5kLFxuICAgICAgICBkdXJhdGlvbjogcnVuVGltZSxcbiAgICAgICAgY29sb3I6IGN1cnJlbnQuY29sb3JcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRpbWUgPSBlbmQ7XG4gICAgY29uc3QgdXBkYXRlZFJlbWFpbmluZyA9IHJlbWFpbmluZ1RpbWUgLSBydW5UaW1lO1xuICAgIHJlbWFpbmluZy5zZXQoY3VycmVudC50YWcsIHVwZGF0ZWRSZW1haW5pbmcpO1xuXG4gICAgaWYgKHVwZGF0ZWRSZW1haW5pbmcgPCAwLjAwMDEpIHtcbiAgICAgIC8vIFByb2Nlc3MgY29tcGxldGVkXG4gICAgICBjb25zdCBidXJzdCA9IGN1cnJlbnQuYnVyc3RUaW1lID8/IGN1cnJlbnQucHJlZGljdGVkQnVyc3RUaW1lID8/IDA7XG4gICAgICBzdGF0cy5zZXQoY3VycmVudC50YWcsIHtcbiAgICAgICAgYXJyaXZhbDogY3VycmVudC5ub3JtYWxpemVkQXJyaXZhbCxcbiAgICAgICAgYnVyc3QsXG4gICAgICAgIGNvbXBsZXRpb246IGVuZFxuICAgICAgfSk7XG4gICAgICByZWFkeS5zaGlmdCgpO1xuICAgIH1cbiAgICAvLyBJZiBub3QgY29tcGxldGVkLCBpdCBzdGF5cyBpbiByZWFkeSBxdWV1ZSBhbmQgd2lsbCBiZSByZXNvcnRlZCBvbiBuZXh0IGl0ZXJhdGlvblxuICB9XG5cbiAgY29uc3QgbWFrZXNwYW4gPSBzZWdtZW50cy5sZW5ndGggPyBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXS5lbmQgOiAwO1xuICBjb25zdCBpZGxlVGltZSA9IHNlZ21lbnRzXG4gICAgLmZpbHRlcigoc2VnbWVudCkgPT4gc2VnbWVudC5waWQgPT09IG51bGwpXG4gICAgLnJlZHVjZSgoYWNjLCBzZWcpID0+IGFjYyArIHNlZy5kdXJhdGlvbiwgMCk7XG5cbiAgcmV0dXJuIHsgc2VnbWVudHMsIHN0YXRzLCBpZGxlVGltZSwgbWFrZXNwYW4sIHRvdGFsQnVyc3QgfTtcbn1cblxuZnVuY3Rpb24gc2ltdWxhdGUoXG4gIGFsZ29yaXRobTogQWxnb3JpdGhtS2V5LFxuICBwcm9jZXNzZXM6IEludGVybmFsUHJvY2Vzc1tdXG4pOiBTaW11bGF0aW9uUmVzdWx0IHtcbiAgc3dpdGNoIChhbGdvcml0aG0pIHtcbiAgICBjYXNlICdGaXJzdCBDb21lIEZpcnN0IFNlcnZlIChGQ0ZTKSc6XG4gICAgICByZXR1cm4gc2ltdWxhdGVGQ0ZTKHByb2Nlc3Nlcyk7XG4gICAgY2FzZSAnU2hvcnRlc3QgSm9iIEZpcnN0IChTSkYpJzpcbiAgICAgIHJldHVybiBzaW11bGF0ZVNKRihwcm9jZXNzZXMpO1xuICAgIGNhc2UgJ1Nob3J0ZXN0IFJlbWFpbmluZyBUaW1lIEZpcnN0IChTUlRGKSc6XG4gICAgICByZXR1cm4gc2ltdWxhdGVTUlRGKHByb2Nlc3Nlcyk7XG4gICAgY2FzZSAnUHJpb3JpdHkgU2NoZWR1bGluZyc6XG4gICAgICByZXR1cm4gc2ltdWxhdGVQcmlvcml0eShwcm9jZXNzZXMpO1xuICAgIGNhc2UgJ011bHRpbGV2ZWwgRmVlZGJhY2sgUXVldWUgKE1MRlEpJzpcbiAgICAgIHJldHVybiBzaW11bGF0ZU1MRlEocHJvY2Vzc2VzKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHNpbXVsYXRlRkNGUyhwcm9jZXNzZXMpO1xuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9jZXNzZXNQYXlsb2FkKHByZWZlcnJlZEFsZ29yaXRobT86IEFsZ29yaXRobUtleSk6IFByb21pc2U8UHJvY2Vzc2VzUGF5bG9hZD4ge1xuICBjb25zdCByZWNvcmRzID0gYXdhaXQgcmVhZENzdlJlY29yZHMoKTtcbiAgY29uc3QgcnVubmluZ1Byb2Nlc3NlcyA9IHJlY29yZHNcbiAgICAuZmlsdGVyKChyZWNvcmQpID0+IHJlY29yZC5zdGF0dXMudG9Mb3dlckNhc2UoKSA9PT0gJ3J1bm5pbmcnKVxuICAgIC5zb3J0KChhLCBiKSA9PiBiLmNwdVBlcmNlbnQgLSBhLmNwdVBlcmNlbnQpO1xuXG4gIGNvbnN0IGRhdGFBbGdvcml0aG1zID0gbmV3IFNldChyZWNvcmRzLm1hcCgocmVjb3JkKSA9PiByZWNvcmQucmVjb21tZW5kZWRBbGdvcml0aG0pKTtcbiAgY29uc3QgY2Fub25pY2FsQWxnb3JpdGhtcyA9IE9iamVjdC5rZXlzKEFMR09SSVRITV9ERVNDUklQVElPTlMpO1xuICBjb25zdCBtZXJnZWRBbGdvcml0aG1zID0gbmV3IFNldDxzdHJpbmc+KFsuLi5jYW5vbmljYWxBbGdvcml0aG1zLCAuLi5kYXRhQWxnb3JpdGhtc10pO1xuXG4gIGNvbnN0IGFsZ29yaXRobXM6IEFsZ29yaXRobVN1bW1hcnlbXSA9IFtcbiAgICAuLi4oWy4uLm1lcmdlZEFsZ29yaXRobXNdXG4gICAgICAuZmlsdGVyKChuYW1lKSA9PiBuYW1lICE9PSAnU2hvcnRlc3QgUmVtYWluaW5nIFRpbWUgRmlyc3QgKFNSVEYpJykgLy8gRXhjbHVkZSBTUlRGIGZyb20gc2VsZWN0b3JcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpXG4gICAgICAubWFwKChuYW1lKSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICBkZXNjcmlwdGlvbjogQUxHT1JJVEhNX0RFU0NSSVBUSU9OU1tuYW1lXSA/PyAnTm8gZGVzY3JpcHRpb24gYXZhaWxhYmxlLicsXG4gICAgICAgIGF2YWlsYWJsZTogZGF0YUFsZ29yaXRobXMuaGFzKG5hbWUpXG4gICAgICB9KSkpLFxuICAgIC8vIEFkZCBcIkNvbXBhcmUgQWxsXCIgb3B0aW9uXG4gICAge1xuICAgICAgbmFtZTogJ0NvbXBhcmUgQWxsJyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnVmlldyBhbGwgYWxnb3JpdGhtcyBzaWRlLWJ5LXNpZGUgYW5kIHNlZSB3aGljaCBwZXJmb3JtcyBiZXN0IG92ZXJhbGwgYmFzZWQgb24gYXZlcmFnZSB3YWl0aW5nIHRpbWUuJyxcbiAgICAgIGF2YWlsYWJsZTogdHJ1ZVxuICAgIH1cbiAgXTtcblxuICAvLyBHZXQgZmlyc3QgYXZhaWxhYmxlIGFsZ29yaXRobSAoZXhjbHVkaW5nIFwiQ29tcGFyZSBBbGxcIilcbiAgY29uc3QgZmlyc3RBdmFpbGFibGUgPSBbLi4uZGF0YUFsZ29yaXRobXNdWzBdID8/IFxuICAgIGFsZ29yaXRobXMuZmluZChhbGcgPT4gYWxnLm5hbWUgIT09ICdDb21wYXJlIEFsbCcpPy5uYW1lID8/IFxuICAgICdGaXJzdCBDb21lIEZpcnN0IFNlcnZlIChGQ0ZTKSc7XG5cbiAgLy8gSGFuZGxlIFwiQ29tcGFyZSBBbGxcIiAtIGRvbid0IHRyZWF0IGl0IGFzIGEgcmVhbCBhbGdvcml0aG0gZm9yIHNjaGVkdWxpbmdcbiAgY29uc3Qgc2VsZWN0ZWRBbGdvcml0aG0gPVxuICAgIHByZWZlcnJlZEFsZ29yaXRobSA9PT0gJ0NvbXBhcmUgQWxsJ1xuICAgICAgPyAnQ29tcGFyZSBBbGwnXG4gICAgICA6IChwcmVmZXJyZWRBbGdvcml0aG0gJiYgbWVyZ2VkQWxnb3JpdGhtcy5oYXMocHJlZmVycmVkQWxnb3JpdGhtKSlcbiAgICAgID8gcHJlZmVycmVkQWxnb3JpdGhtXG4gICAgICA6IGZpcnN0QXZhaWxhYmxlO1xuXG4gIC8vIEdldCBhbGwgcHJvY2Vzc2VzIHRoYXQgaGF2ZSBidXJzdCB0aW1lIGFuZCBhcnJpdmFsIHRpbWUgZm9yIHNjaGVkdWxpbmdcbiAgY29uc3Qgc2NoZWR1bGFibGVQcm9jZXNzZXMgPSByZWNvcmRzXG4gICAgLmZpbHRlcigocmVjb3JkKSA9PlxuICAgICAgKHJlY29yZC5idXJzdFRpbWUgPz8gcmVjb3JkLnByZWRpY3RlZEJ1cnN0VGltZSA/PyAwKSA+IDAgJiZcbiAgICAgIHJlY29yZC5hcnJpdmFsVGltZSAhPT0gbnVsbFxuICAgIClcbiAgICAuc29ydCgoYSwgYikgPT4gKGEuYXJyaXZhbFRpbWUgPz8gMCkgLSAoYi5hcnJpdmFsVGltZSA/PyAwKSk7XG5cbiAgY29uc3QgbGltaXRlZCA9IHNjaGVkdWxhYmxlUHJvY2Vzc2VzLnNsaWNlKDAsIDEwKTtcbiAgY29uc3QgaW50ZXJuYWxQcm9jZXNzZXMgPSBub3JtYWxpemVQcm9jZXNzZXMobGltaXRlZCk7XG5cbiAgLy8gQ29tcHV0ZSBzY2hlZHVsZXMgZm9yIGFsbCBhbGdvcml0aG1zIChleGNsdWRpbmcgU1JURiBzaW5jZSBpdCdzIG5vdCBpbiB0aGUgZGF0YXNldClcbiAgY29uc3QgYWxsU2NoZWR1bGVzOiBSZWNvcmQ8QWxnb3JpdGhtS2V5LCBTY2hlZHVsZVBheWxvYWQgfCBudWxsPiA9IHt9O1xuICBjb25zdCBhbGdvcml0aG1NZXRyaWNzOiBSZWNvcmQ8QWxnb3JpdGhtS2V5LCB7IGF2Z1dhaXRpbmc6IG51bWJlcjsgYXZnVHVybmFyb3VuZDogbnVtYmVyIH0+ID0ge307XG5cbiAgLy8gRmlsdGVyIG91dCBTUlRGIGZyb20gYWxnb3JpdGhtcyB0byBjb21wdXRlIChvbmx5IGNvbXB1dGUgYWxnb3JpdGhtcyB0aGF0IGFyZSBpbiB0aGUgZGF0YXNldCBvciBhdmFpbGFibGUpXG4gIGNvbnN0IGFsZ29yaXRobXNUb0NvbXB1dGUgPSBjYW5vbmljYWxBbGdvcml0aG1zLmZpbHRlcihcbiAgICAoYWxnTmFtZSkgPT4gYWxnTmFtZSAhPT0gJ1Nob3J0ZXN0IFJlbWFpbmluZyBUaW1lIEZpcnN0IChTUlRGKSdcbiAgKTtcblxuICBmb3IgKGNvbnN0IGFsZ05hbWUgb2YgYWxnb3JpdGhtc1RvQ29tcHV0ZSkge1xuICAgIGlmIChpbnRlcm5hbFByb2Nlc3Nlcy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNpbXVsYXRpb24gPSBzaW11bGF0ZShhbGdOYW1lLCBpbnRlcm5hbFByb2Nlc3Nlcyk7XG4gICAgICBjb25zdCBtZXRyaWNzID0gY29tcHV0ZU1ldHJpY3MoXG4gICAgICAgIHNpbXVsYXRpb24uc3RhdHMsXG4gICAgICAgIHNpbXVsYXRpb24uc2VnbWVudHMsXG4gICAgICAgIHNpbXVsYXRpb24udG90YWxCdXJzdCxcbiAgICAgICAgc2ltdWxhdGlvbi5pZGxlVGltZVxuICAgICAgKTtcblxuICAgICAgY29uc3QgY29sb3JNYXAgPSBuZXcgTWFwKGludGVybmFsUHJvY2Vzc2VzLm1hcCgocHJvYykgPT4gW3Byb2MudGFnLCBwcm9jLmNvbG9yXSkpO1xuICAgICAgY29uc3QgdGFibGUgPSBidWlsZFRhYmxlKHNpbXVsYXRpb24uc3RhdHMsIGludGVybmFsUHJvY2Vzc2VzLCBjb2xvck1hcCk7XG5cbiAgICAgIGFsbFNjaGVkdWxlc1thbGdOYW1lXSA9IHtcbiAgICAgICAgc2VnbWVudHM6IGZvcm1hdFNlZ21lbnRzKHNpbXVsYXRpb24uc2VnbWVudHMpLFxuICAgICAgICB0YWJsZSxcbiAgICAgICAgbWV0cmljc1xuICAgICAgfTtcblxuICAgICAgYWxnb3JpdGhtTWV0cmljc1thbGdOYW1lXSA9IHtcbiAgICAgICAgYXZnV2FpdGluZzogbWV0cmljcy5hdmVyYWdlV2FpdGluZ1RpbWUsXG4gICAgICAgIGF2Z1R1cm5hcm91bmQ6IG1ldHJpY3MuYXZlcmFnZVR1cm5hcm91bmRUaW1lXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBhbGxTY2hlZHVsZXNbYWxnTmFtZV0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8vIERldGVybWluZSBiZXN0IGFsZ29yaXRobSBmb3IgZWFjaCBwcm9jZXNzIGJhc2VkIG9uIHdhaXRpbmcgdGltZVxuICBjb25zdCBwcm9jZXNzQmVzdEFsZ29yaXRobSA9IG5ldyBNYXA8bnVtYmVyLCBBbGdvcml0aG1LZXk+KCk7XG4gIGZvciAoY29uc3QgcHJvY2VzcyBvZiBsaW1pdGVkKSB7XG4gICAgbGV0IGJlc3RBbGc6IEFsZ29yaXRobUtleSB8IG51bGwgPSBudWxsO1xuICAgIGxldCBiZXN0V2FpdGluZyA9IEluZmluaXR5O1xuXG4gICAgZm9yIChjb25zdCBbYWxnTmFtZSwgc2NoZWR1bGVdIG9mIE9iamVjdC5lbnRyaWVzKGFsbFNjaGVkdWxlcykpIHtcbiAgICAgIGlmICghc2NoZWR1bGUpIGNvbnRpbnVlO1xuICAgICAgY29uc3QgcHJvY2Vzc1JvdyA9IHNjaGVkdWxlLnRhYmxlLmZpbmQoKHJvdykgPT4gcm93LnBpZCA9PT0gcHJvY2Vzcy5waWQpO1xuICAgICAgaWYgKHByb2Nlc3NSb3cgJiYgcHJvY2Vzc1Jvdy53YWl0aW5nVGltZSA8IGJlc3RXYWl0aW5nKSB7XG4gICAgICAgIGJlc3RXYWl0aW5nID0gcHJvY2Vzc1Jvdy53YWl0aW5nVGltZTtcbiAgICAgICAgYmVzdEFsZyA9IGFsZ05hbWUgYXMgQWxnb3JpdGhtS2V5O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiZXN0QWxnKSB7XG4gICAgICBwcm9jZXNzQmVzdEFsZ29yaXRobS5zZXQocHJvY2Vzcy5waWQsIGJlc3RBbGcpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBzY2hlZHVsZSBmb3Igc2VsZWN0ZWQgYWxnb3JpdGhtIChza2lwIGlmIFwiQ29tcGFyZSBBbGxcIilcbiAgY29uc3Qgc2NoZWR1bGUgPSBzZWxlY3RlZEFsZ29yaXRobSA9PT0gJ0NvbXBhcmUgQWxsJyA/IG51bGwgOiAoYWxsU2NoZWR1bGVzW3NlbGVjdGVkQWxnb3JpdGhtXSA/PyBudWxsKTtcblxuICBjb25zdCBwcm9jZXNzT3ZlcnZpZXc6IFByb2Nlc3NPdmVydmlld1tdID0gcnVubmluZ1Byb2Nlc3Nlcy5tYXAoKHByb2Nlc3MpID0+IHtcbiAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzLmZpbmQoKHIpID0+IHIucGlkID09PSBwcm9jZXNzLnBpZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBpZDogcHJvY2Vzcy5waWQsXG4gICAgICB0YWc6IGBQSUQgJHtwcm9jZXNzLnBpZH1gLFxuICAgICAgbmFtZTogcHJvY2Vzcy5uYW1lLFxuICAgICAgYWxnb3JpdGhtOiBwcm9jZXNzLnJlY29tbWVuZGVkQWxnb3JpdGhtLFxuICAgICAgY3B1UGVyY2VudDogTnVtYmVyKHByb2Nlc3MuY3B1UGVyY2VudC50b0ZpeGVkKDIpKSxcbiAgICAgIG1lbW9yeU1iOiBOdW1iZXIocHJvY2Vzcy5tZW1vcnlNYi50b0ZpeGVkKDIpKSxcbiAgICAgIHN0YXR1czogcHJvY2Vzcy5zdGF0dXMsXG4gICAgICBwcmVkaWN0ZWRCdXJzdFRpbWU6IHJlY29yZD8ucHJlZGljdGVkQnVyc3RUaW1lID8/IG51bGwsXG4gICAgICBwcmVkaWN0ZWRUaW1lUXVhbnR1bTogcmVjb3JkPy5wcmVkaWN0ZWRUaW1lUXVhbnR1bSA/PyBudWxsLFxuICAgICAgYmVzdEFsZ29yaXRobTogcHJvY2Vzc0Jlc3RBbGdvcml0aG0uZ2V0KHByb2Nlc3MucGlkKVxuICAgIH07XG4gIH0pO1xuXG4gIGxldCBsYXRlc3RUaW1lc3RhbXA6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuICBmb3IgKGNvbnN0IHJlY29yZCBvZiByZWNvcmRzKSB7XG4gICAgaWYgKCFyZWNvcmQudGltZXN0YW1wKSBjb250aW51ZTtcbiAgICBjb25zdCBtaWxsaXMgPSBEYXRlLnBhcnNlKHJlY29yZC50aW1lc3RhbXApO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG1pbGxpcykpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoIWxhdGVzdFRpbWVzdGFtcCB8fCBtaWxsaXMgPiBEYXRlLnBhcnNlKGxhdGVzdFRpbWVzdGFtcCkpIHtcbiAgICAgIGxhdGVzdFRpbWVzdGFtcCA9IHJlY29yZC50aW1lc3RhbXA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhbGdvcml0aG1zLFxuICAgIHNlbGVjdGVkQWxnb3JpdGhtLFxuICAgIGFsZ29yaXRobURlc2NyaXB0aW9uOiBzZWxlY3RlZEFsZ29yaXRobSA9PT0gJ0NvbXBhcmUgQWxsJyBcbiAgICAgID8gJ1ZpZXcgYWxsIGFsZ29yaXRobXMgc2lkZS1ieS1zaWRlIGFuZCBzZWUgd2hpY2ggcGVyZm9ybXMgYmVzdCBvdmVyYWxsIGJhc2VkIG9uIGF2ZXJhZ2Ugd2FpdGluZyB0aW1lLidcbiAgICAgIDogKEFMR09SSVRITV9ERVNDUklQVElPTlNbc2VsZWN0ZWRBbGdvcml0aG1dID8/ICdTY2hlZHVsaW5nIHZpc3VhbGl6YXRpb24nKSxcbiAgICBwcm9jZXNzZXM6IHByb2Nlc3NPdmVydmlldyxcbiAgICBzY2hlZHVsZSxcbiAgICBhbGxTY2hlZHVsZXMsXG4gICAgbGFzdFVwZGF0ZWQ6IGxhdGVzdFRpbWVzdGFtcFxuICB9O1xufVxuIl0sIm5hbWVzIjpbInByb21pc2VzIiwiZnMiLCJwYXRoIiwicGFyc2UiLCJBTEdPUklUSE1fREVTQ1JJUFRJT05TIiwiRVhDTFVERURfQUxHT1JJVEhNUyIsIlNldCIsIkRFRkFVTFRfREFUQV9GSUxFIiwiam9pbiIsInByb2Nlc3MiLCJjd2QiLCJDT0xPUl9QQUxFVFRFIiwidG9OdW1iZXIiLCJ2YWx1ZSIsInRyaW0iLCJudW0iLCJOdW1iZXIiLCJpc0Zpbml0ZSIsInJlYWRDc3ZSZWNvcmRzIiwiZmlsZVBhdGgiLCJlbnYiLCJTQ0hFRFVMRVJfREFUQV9GSUxFIiwiY29udGVudCIsInJlYWRGaWxlIiwicmVjb3JkcyIsImNvbHVtbnMiLCJza2lwX2VtcHR5X2xpbmVzIiwibGF0ZXN0QnlQaWQiLCJNYXAiLCJyZWNvcmQiLCJwaWQiLCJidXJzdFRpbWUiLCJidXJzdF90aW1lIiwicHJlZGljdGVkX2J1cnN0X3RpbWUiLCJhcnJpdmFsVGltZSIsImFycml2YWxfdGltZSIsInN5c3RlbVRpbWVzdGFtcCIsInN5c3RlbV90aW1lc3RhbXAiLCJwYXJzZWQiLCJzbmFwc2hvdElkIiwic25hcHNob3RfaWQiLCJ0aW1lc3RhbXAiLCJuYW1lIiwic3RhdHVzIiwicHBpZCIsImNwdVBlcmNlbnQiLCJjcHVfcGVyY2VudCIsIm1lbW9yeVBlcmNlbnQiLCJtZW1vcnlfcGVyY2VudCIsIm1lbW9yeU1iIiwibWVtb3J5X21iIiwibnVtVGhyZWFkcyIsIm51bV90aHJlYWRzIiwibmljZSIsInByb2Nlc3NBZ2UiLCJwcm9jZXNzX2FnZSIsInByb2Nlc3NUeXBlIiwicHJvY2Vzc190eXBlIiwiaW9JbnRlbnNpdHkiLCJpb19pbnRlbnNpdHkiLCJ1c2VyVGltZSIsInVzZXJfdGltZSIsInN5c3RlbVRpbWUiLCJzeXN0ZW1fdGltZSIsInByZWRpY3RlZEJ1cnN0VGltZSIsInByZWRpY3RlZFRpbWVRdWFudHVtIiwicHJlZGljdGVkX3RpbWVfcXVhbnR1bSIsInByZWRpY3RlZFByaW9yaXR5IiwicHJlZGljdGVkX3ByaW9yaXR5IiwicmVjb21tZW5kZWRBbGdvcml0aG0iLCJyZWNvbW1lbmRlZF9hbGdvcml0aG0iLCJoYXMiLCJleGlzdGluZyIsImdldCIsInNldCIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsIm5vcm1hbGl6ZVByb2Nlc3NlcyIsInByb2Nlc3NlcyIsImFycml2YWxWYWx1ZXMiLCJtYXAiLCJwIiwiZmlsdGVyIiwibWluQXJyaXZhbCIsImxlbmd0aCIsIk1hdGgiLCJtaW4iLCJpbmRleCIsImJ1cnN0IiwiYXJyaXZhbCIsIm5vcm1hbGl6ZWRBcnJpdmFsIiwicmVtYWluaW5nVGltZSIsInRhZyIsImNvbG9yIiwiYWRkSWRsZVNlZ21lbnQiLCJzZWdtZW50cyIsImN1cnJlbnRUaW1lIiwibmV4dFRpbWUiLCJwdXNoIiwibGFiZWwiLCJzdGFydCIsImVuZCIsImR1cmF0aW9uIiwic2ltdWxhdGVGQ0ZTIiwic29ydGVkIiwic3RhdHMiLCJ0aW1lIiwidG90YWxCdXJzdCIsInJlZHVjZSIsImFjYyIsInByb2MiLCJjb21wbGV0aW9uIiwibWFrZXNwYW4iLCJpZGxlVGltZSIsInNlZ21lbnQiLCJzZWciLCJzaW11bGF0ZVByaW9yaXR5IiwicmVtYWluaW5nIiwic29ydGVkQnlBcnJpdmFsIiwicmVhZHkiLCJpZHgiLCJzaXplIiwibmV4dEFycml2YWwiLCJ1bmRlZmluZWQiLCJwcmlvcml0eUEiLCJNQVhfU0FGRV9JTlRFR0VSIiwicHJpb3JpdHlCIiwiY3VycmVudCIsInNoaWZ0IiwibWF4Iiwic2ltdWxhdGVNTEZRIiwicXVhbnR1bXMiLCJxdWV1ZXMiLCJlbnF1ZXVlTmV3QXJyaXZhbHMiLCJoYXNSZWFkeSIsInNvbWUiLCJxIiwibGV2ZWwiLCJmaW5kSW5kZXgiLCJxdWFudHVtIiwicHJlZGljdGVkUXVhbnR1bSIsImFjdHVhbFJ1biIsInF1ZXVlTGV2ZWwiLCJ0aW1lUXVhbnR1bSIsInVwZGF0ZWRSZW1haW5pbmciLCJuZXh0TGV2ZWwiLCJjb21wdXRlTWV0cmljcyIsImF2ZXJhZ2VCdXJzdFRpbWUiLCJhdmVyYWdlVHVybmFyb3VuZFRpbWUiLCJhdmVyYWdlV2FpdGluZ1RpbWUiLCJ0aHJvdWdocHV0IiwiY3B1VXRpbGl6YXRpb24iLCJ0b3RhbFR1cm5hcm91bmQiLCJ0b3RhbFdhaXRpbmciLCJhdmdCdXJzdCIsImJ1c3lUaW1lIiwiYnVpbGRUYWJsZSIsImNvbG9yQnlUYWciLCJ0YWdUb1Byb2Nlc3MiLCJlbnRyaWVzIiwiRXJyb3IiLCJ0b0ZpeGVkIiwid2FpdGluZ1RpbWUiLCJ0dXJuYXJvdW5kVGltZSIsImNvbXBsZXRpb25UaW1lIiwiZm9ybWF0U2VnbWVudHMiLCJzaW11bGF0ZVNKRiIsImJ1cnN0QSIsImJ1cnN0QiIsImFicyIsInNpbXVsYXRlU1JURiIsInJlbWFpbmluZ0EiLCJyZW1haW5pbmdCIiwidGltZVVudGlsTmV4dCIsIkluZmluaXR5IiwicnVuVGltZSIsImxhc3RTZWdtZW50Iiwic2ltdWxhdGUiLCJhbGdvcml0aG0iLCJnZXRQcm9jZXNzZXNQYXlsb2FkIiwicHJlZmVycmVkQWxnb3JpdGhtIiwicnVubmluZ1Byb2Nlc3NlcyIsInRvTG93ZXJDYXNlIiwiZGF0YUFsZ29yaXRobXMiLCJjYW5vbmljYWxBbGdvcml0aG1zIiwiT2JqZWN0Iiwia2V5cyIsIm1lcmdlZEFsZ29yaXRobXMiLCJhbGdvcml0aG1zIiwibG9jYWxlQ29tcGFyZSIsImRlc2NyaXB0aW9uIiwiYXZhaWxhYmxlIiwiZmlyc3RBdmFpbGFibGUiLCJmaW5kIiwiYWxnIiwic2VsZWN0ZWRBbGdvcml0aG0iLCJzY2hlZHVsYWJsZVByb2Nlc3NlcyIsImxpbWl0ZWQiLCJzbGljZSIsImludGVybmFsUHJvY2Vzc2VzIiwiYWxsU2NoZWR1bGVzIiwiYWxnb3JpdGhtTWV0cmljcyIsImFsZ29yaXRobXNUb0NvbXB1dGUiLCJhbGdOYW1lIiwic2ltdWxhdGlvbiIsIm1ldHJpY3MiLCJjb2xvck1hcCIsInRhYmxlIiwiYXZnV2FpdGluZyIsImF2Z1R1cm5hcm91bmQiLCJwcm9jZXNzQmVzdEFsZ29yaXRobSIsImJlc3RBbGciLCJiZXN0V2FpdGluZyIsInNjaGVkdWxlIiwicHJvY2Vzc1JvdyIsInJvdyIsInByb2Nlc3NPdmVydmlldyIsInIiLCJiZXN0QWxnb3JpdGhtIiwibGF0ZXN0VGltZXN0YW1wIiwibWlsbGlzIiwiRGF0ZSIsImFsZ29yaXRobURlc2NyaXB0aW9uIiwibGFzdFVwZGF0ZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./lib/processData.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/csv-parse"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fprocesses%2Froute&page=%2Fapi%2Fprocesses%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fprocesses%2Froute.ts&appDir=%2Fhome%2Fabhijeet%2FDesktop%2FOS%2Fapp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=%2Fhome%2Fabhijeet%2FDesktop%2FOS&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();